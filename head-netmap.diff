Index: conf/NOTES
===================================================================
--- conf/NOTES	(revision 225462)
+++ conf/NOTES	(working copy)
@@ -799,6 +799,12 @@
 #  option.  DHCP requires bpf.
 device		bpf
 
+#  The `netmap' device implements memory-mapped access to network
+#  devices from userspace, enabling wire-speed packet capture and
+#  generation even at 10Gbit/s. Requires support in the device
+#  driver. Supported drivers are ixgbe, e1000, re.
+device		netmap
+
 #  The `disc' device implements a minimal network interface,
 #  which throws away all packets sent and never receives any.  It is
 #  included for testing and benchmarking purposes.
Index: conf/files
===================================================================
--- conf/files	(revision 225462)
+++ conf/files	(working copy)
@@ -1510,6 +1510,7 @@
 dev/my/if_my.c			optional my
 dev/ncv/ncr53c500.c		optional ncv
 dev/ncv/ncr53c500_pccard.c	optional ncv pccard
+dev/netmap/netmap.c		optional netmap
 dev/nge/if_nge.c		optional nge
 dev/nxge/if_nxge.c		optional nxge
 dev/nxge/xgehal/xgehal-device.c	optional nxge
Index: conf/options
===================================================================
--- conf/options	(revision 225462)
+++ conf/options	(working copy)
@@ -687,6 +687,7 @@
 
 # various 'device presence' options.
 DEV_BPF			opt_bpf.h
+DEV_NETMAP		opt_global.h
 DEV_MCA			opt_mca.h
 DEV_CARP		opt_carp.h
 DEV_SPLASH		opt_splash.h
Index: dev/e1000/if_igb.c
===================================================================
--- dev/e1000/if_igb.c	(revision 225462)
+++ dev/e1000/if_igb.c	(working copy)
@@ -369,6 +369,9 @@
     &igb_rx_process_limit, 0,
     "Maximum number of received packets to process at a time, -1 means unlimited");
 
+#ifdef DEV_NETMAP
+#include <dev/netmap/if_igb_netmap.h>
+#endif /* DEV_NETMAP */
 /*********************************************************************
  *  Device identification routine
  *
@@ -664,6 +667,9 @@
 	adapter->led_dev = led_create(igb_led_func, adapter,
 	    device_get_nameunit(dev));
 
+#ifdef DEV_NETMAP
+	igb_netmap_attach(adapter);
+#endif /* DEV_NETMAP */
 	INIT_DEBUGOUT("igb_attach: end");
 
 	return (0);
@@ -742,6 +748,9 @@
 
 	callout_drain(&adapter->timer);
 
+#ifdef DEV_NETMAP
+	netmap_detach(adapter->ifp);
+#endif /* DEV_NETMAP */
 	igb_free_pci_resources(adapter);
 	bus_generic_detach(dev);
 	if_free(ifp);
@@ -3212,6 +3221,10 @@
 	struct adapter *adapter = txr->adapter;
 	struct igb_tx_buffer *txbuf;
 	int i;
+#ifdef DEV_NETMAP
+	struct netmap_slot *slot = netmap_reset(NA(adapter->ifp),
+		NR_TX, txr->me, 0);
+#endif
 
 	/* Clear the old descriptor contents */
 	IGB_TX_LOCK(txr);
@@ -3231,6 +3244,13 @@
 			m_freem(txbuf->m_head);
 			txbuf->m_head = NULL;
 		}
+#ifdef DEV_NETMAP
+		if (slot) {
+			netmap_load_map(txr->txtag, txbuf->map,
+				NMB(slot), adapter->rx_mbuf_sz);
+			slot++;
+		}
+#endif /* DEV_NETMAP */
 		/* clear the watch index */
 		txbuf->next_eop = -1;
         }
@@ -3626,6 +3646,17 @@
 
 	IGB_TX_LOCK_ASSERT(txr);
 
+#ifdef DEV_NETMAP
+	if (ifp->if_capenable & IFCAP_NETMAP) {
+		selwakeuppri(&NA(ifp)->tx_rings[txr->me].si, PI_NET);
+		IGB_TX_UNLOCK(txr);
+		IGB_CORE_LOCK(adapter);
+		selwakeuppri(&NA(ifp)->tx_rings[adapter->num_queues + 1].si, PI_NET);
+		IGB_CORE_UNLOCK(adapter);
+		IGB_TX_LOCK(txr); // the caller is supposed to own the lock
+		return FALSE;
+	}
+#endif /* DEV_NETMAP */
         if (txr->tx_avail == adapter->num_tx_desc) {
 		txr->queue_status = IGB_QUEUE_IDLE;
                 return FALSE;
@@ -3949,6 +3980,10 @@
 	bus_dma_segment_t	pseg[1], hseg[1];
 	struct lro_ctrl		*lro = &rxr->lro;
 	int			rsize, nsegs, error = 0;
+#ifdef DEV_NETMAP
+	struct netmap_slot *slot = netmap_reset(NA(rxr->adapter->ifp),
+				NR_RX, rxr->me, 0);
+#endif
 
 	adapter = rxr->adapter;
 	dev = adapter->dev;
@@ -3974,6 +4009,18 @@
 		struct mbuf	*mh, *mp;
 
 		rxbuf = &rxr->rx_buffers[j];
+#ifdef DEV_NETMAP
+		if (slot) {
+			netmap_load_map(rxr->ptag,
+					rxbuf->pmap, NMB(slot),
+					adapter->rx_mbuf_sz);
+			/* Update descriptor */
+			rxr->rx_base[j].read.pkt_addr =
+				htole64(vtophys(NMB(slot)));
+			slot++;
+			continue;
+		}
+#endif /* DEV_NETMAP */
 		if (rxr->hdr_split == FALSE)
 			goto skip_head;
 
@@ -4436,6 +4483,17 @@
 	bus_dmamap_sync(rxr->rxdma.dma_tag, rxr->rxdma.dma_map,
 	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_POSTWRITE);
 
+#ifdef DEV_NETMAP
+	if (ifp->if_capenable & IFCAP_NETMAP) {
+		selwakeuppri(&NA(ifp)->rx_rings[rxr->me].si, PI_NET);
+		IGB_RX_UNLOCK(rxr);
+		IGB_CORE_LOCK(adapter);
+		selwakeuppri(&NA(ifp)->rx_rings[adapter->num_queues + 1].si, PI_NET);
+		IGB_CORE_UNLOCK(adapter);
+		return (0);
+	}
+#endif /* DEV_NETMAP */
+
 	/* Main clean loop */
 	for (i = rxr->next_to_check; count != 0;) {
 		struct mbuf		*sendmp, *mh, *mp;
Index: dev/e1000/if_lem.c
===================================================================
--- dev/e1000/if_lem.c	(revision 225462)
+++ dev/e1000/if_lem.c	(working copy)
@@ -316,6 +316,10 @@
 /* Global used in WOL setup with multiport cards */
 static int global_quad_port_a = 0;
 
+#ifdef DEV_NETMAP
+#include <dev/netmap/if_lem_netmap.h>
+#endif /* DEV_NETMAP */
+
 /*********************************************************************
  *  Device identification routine
  *
@@ -646,6 +650,9 @@
 	adapter->led_dev = led_create(lem_led_func, adapter,
 	    device_get_nameunit(dev));
 
+#ifdef DEV_NETMAP
+	lem_netmap_attach(adapter);
+#endif /* DEV_NETMAP */
 	INIT_DEBUGOUT("lem_attach: end");
 
 	return (0);
@@ -724,6 +731,9 @@
 	callout_drain(&adapter->timer);
 	callout_drain(&adapter->tx_fifo_timer);
 
+#ifdef DEV_NETMAP
+	netmap_detach(ifp);
+#endif /* DEV_NETMAP */
 	lem_free_pci_resources(adapter);
 	bus_generic_detach(dev);
 	if_free(ifp);
@@ -1346,6 +1356,10 @@
 
 
 	if (ifp->if_drv_flags & IFF_DRV_RUNNING) {
+#ifdef LATENCY_TIMESTAMPS // XXX store a timestamp into ispare
+		/* take the timestamp whch marks the interrupt has come. */
+		lem_intr_ts0 = rdtsc();
+#endif /* LATENCY_TIMESTAMPS */
 		lem_rxeof(adapter, adapter->rx_process_limit, NULL);
 		EM_TX_LOCK(adapter);
 		lem_txeof(adapter);
@@ -1621,6 +1635,7 @@
 	if (adapter->pcix_82544) 
 		txd_saved = i;
 
+	// XXX store a timestamp into the packet, for icmp
 	/* Set up our transmit descriptors */
 	for (j = 0; j < nsegs; j++) {
 		bus_size_t seg_len;
@@ -2637,6 +2652,9 @@
 lem_setup_transmit_structures(struct adapter *adapter)
 {
 	struct em_buffer *tx_buffer;
+#ifdef DEV_NETMAP
+	struct netmap_slot *slot = netmap_reset(NA(adapter->ifp), NR_TX, 0, 0);
+#endif
 
 	/* Clear the old ring contents */
 	bzero(adapter->tx_desc_base,
@@ -2650,6 +2668,16 @@
 		bus_dmamap_unload(adapter->txtag, tx_buffer->map);
 		m_freem(tx_buffer->m_head);
 		tx_buffer->m_head = NULL;
+#ifdef DEV_NETMAP
+		if (slot) {
+			/* reload the map for netmap mode */
+			netmap_load_map(adapter->txtag,
+				tx_buffer->map, NMB(slot),
+				NA(adapter->ifp)->buff_size);
+			slot++;
+		}
+#endif /* DEV_NETMAP */
+
 		tx_buffer->next_eop = -1;
 	}
 
@@ -2950,6 +2978,12 @@
 
 	EM_TX_LOCK_ASSERT(adapter);
 
+#ifdef DEV_NETMAP
+	if (ifp->if_capenable & IFCAP_NETMAP) {
+		selwakeuppri(&NA(ifp)->tx_rings[0].si, PI_NET);
+		return;
+	}
+#endif /* DEV_NETMAP */
         if (adapter->num_tx_desc_avail == adapter->num_tx_desc)
                 return;
 
@@ -3180,6 +3214,9 @@
 {
 	struct em_buffer *rx_buffer;
 	int i, error;
+#ifdef DEV_NETMAP
+	struct netmap_slot *slot = netmap_reset(NA(adapter->ifp), NR_RX, 0, 0);
+#endif
 
 	/* Reset descriptor ring */
 	bzero(adapter->rx_desc_base,
@@ -3199,6 +3236,18 @@
 
 	/* Allocate new ones. */
 	for (i = 0; i < adapter->num_rx_desc; i++) {
+#ifdef DEV_NETMAP
+		if (slot) {
+			netmap_load_map(adapter->rxtag,
+				rx_buffer->map, NMB(slot),
+				NA(adapter->ifp)->buff_size);
+			/* Update descriptor */
+			adapter->rx_desc_base[i].buffer_addr =
+				htole64(vtophys(NMB(slot)));
+			slot++;
+			continue;
+		}
+#endif /* DEV_NETMAP */
 		error = lem_get_buf(adapter, i);
 		if (error)
                         return (error);
@@ -3406,6 +3455,18 @@
 	bus_dmamap_sync(adapter->rxdma.dma_tag, adapter->rxdma.dma_map,
 	    BUS_DMASYNC_POSTREAD);
 
+#ifdef DEV_NETMAP
+#if NETMAP_LATENCY_TIMESTAMPS
+	netmap_rdtsc(lem_intr_ts0);
+	STATS_ADD(lem_stats, ifp->if_dunit, 0);
+#endif /* NETMAP_LATENCY_TIMESTAMPS */
+	if (ifp->if_capenable & IFCAP_NETMAP) {
+		selwakeuppri(&NA(ifp)->rx_rings[0].si, PI_NET);
+		EM_RX_UNLOCK(adapter);
+		return (0);
+	}
+#endif /* DEV_NETMAP */
+
 	if (!((current_desc->status) & E1000_RXD_STAT_DD)) {
 		if (done != NULL)
 			*done = rx_sent;
Index: dev/e1000/if_em.c
===================================================================
--- dev/e1000/if_em.c	(revision 225462)
+++ dev/e1000/if_em.c	(working copy)
@@ -399,6 +399,10 @@
 /* Global used in WOL setup with multiport cards */
 static int global_quad_port_a = 0;
 
+#ifdef DEV_NETMAP
+#include <dev/netmap/if_em_netmap.h>
+#endif /* DEV_NETMAP */
+
 /*********************************************************************
  *  Device identification routine
  *
@@ -714,6 +718,9 @@
 
 	adapter->led_dev = led_create(em_led_func, adapter,
 	    device_get_nameunit(dev));
+#ifdef DEV_NETMAP
+	em_netmap_attach(adapter);
+#endif /* DEV_NETMAP */
 
 	INIT_DEBUGOUT("em_attach: end");
 
@@ -785,6 +792,10 @@
 	ether_ifdetach(adapter->ifp);
 	callout_drain(&adapter->timer);
 
+#ifdef DEV_NETMAP
+	netmap_detach(ifp);
+#endif /* DEV_NETMAP */
+
 	em_free_pci_resources(adapter);
 	bus_generic_detach(dev);
 	if_free(ifp);
@@ -3213,6 +3224,10 @@
 	struct adapter *adapter = txr->adapter;
 	struct em_buffer *txbuf;
 	int i;
+#ifdef DEV_NETMAP
+	struct netmap_slot *slot = netmap_reset(NA(adapter->ifp),
+		NR_TX, txr->me, 0);
+#endif
 
 	/* Clear the old descriptor contents */
 	EM_TX_LOCK(txr);
@@ -3232,6 +3247,16 @@
 			m_freem(txbuf->m_head);
 			txbuf->m_head = NULL;
 		}
+#ifdef DEV_NETMAP
+		if (slot) {
+			/* reload the map for netmap mode */
+			netmap_load_map(txr->txtag,
+					txbuf->map, NMB(slot),
+					adapter->rx_mbuf_sz);
+			slot++;
+		}
+#endif /* DEV_NETMAP */
+
 		/* clear the watch index */
 		txbuf->next_eop = -1;
         }
@@ -3682,6 +3707,12 @@
 	struct ifnet   *ifp = adapter->ifp;
 
 	EM_TX_LOCK_ASSERT(txr);
+#ifdef DEV_NETMAP
+	if (ifp->if_capenable & IFCAP_NETMAP) {
+		selwakeuppri(&NA(ifp)->tx_rings[txr->me].si, PI_NET);
+		return (FALSE);
+	}
+#endif /* DEV_NETMAP */
 
 	/* No work, make sure watchdog is off */
         if (txr->tx_avail == adapter->num_tx_desc) {
@@ -3978,6 +4009,33 @@
 		if (++j == adapter->num_rx_desc)
 			j = 0;
 	}
+#ifdef DEV_NETMAP
+    {
+	/* slot is NULL if we are not in netmap mode */
+	struct netmap_slot *slot = netmap_reset(NA(adapter->ifp),
+		NR_RX, rxr->me, rxr->next_to_check);
+	/*
+	 * we need to restore all buffer addresses in the ring as they might
+	 * be in the wrong state if we are exiting from netmap mode.
+	 */
+	for (j = 0; j != adapter->num_rx_desc; ++j) {
+		void *addr;
+		rxbuf = &rxr->rx_buffers[j];
+		if (rxbuf->m_head == NULL && !slot)
+			continue;
+		addr = slot ? NMB(slot) : rxbuf->m_head->m_data;
+		// XXX load or reload ?
+		netmap_load_map(rxr->rxtag, rxbuf->map, addr, adapter->rx_mbuf_sz);
+		/* Update descriptor */
+		rxr->rx_base[j].buffer_addr = htole64(vtophys(addr));
+		bus_dmamap_sync(rxr->rxtag, rxbuf->map, BUS_DMASYNC_PREREAD);
+		if (slot)
+			slot++;
+	}
+	/* Setup our descriptor indices */
+	NA(adapter->ifp)->rx_rings[rxr->me].nr_hwcur = rxr->next_to_check;
+    }
+#endif /* DEV_NETMAP */
 
 fail:
 	rxr->next_to_refresh = i;
@@ -4247,6 +4305,14 @@
 
 	EM_RX_LOCK(rxr);
 
+#ifdef DEV_NETMAP
+	if (ifp->if_capenable & IFCAP_NETMAP) {
+		selwakeuppri(&NA(ifp)->rx_rings[rxr->me].si, PI_NET);
+		EM_RX_UNLOCK(rxr);
+		return (0);
+	}
+#endif /* DEV_NETMAP */
+
 	for (i = rxr->next_to_check, processed = 0; count != 0;) {
 
 		if ((ifp->if_drv_flags & IFF_DRV_RUNNING) == 0)
Index: dev/re/if_re.c
===================================================================
--- dev/re/if_re.c	(revision 225462)
+++ dev/re/if_re.c	(working copy)
@@ -291,6 +291,11 @@
 static void re_setwol		(struct rl_softc *);
 static void re_clrwol		(struct rl_softc *);
 
+#include <dev/netmap/if_re_tweaks.h>
+#ifdef DEV_NETMAP
+#include <dev/netmap/if_re_netmap.h>
+#endif /* !DEV_NETMAP */
+
 #ifdef RE_DIAG
 static int re_diag		(struct rl_softc *);
 #endif
@@ -1583,6 +1588,10 @@
 	 */
 	ifp->if_data.ifi_hdrlen = sizeof(struct ether_vlan_header);
 
+#ifdef DEV_NETMAP
+	re_netmap_attach(sc);
+#endif /* DEV_NETMAP */
+
 #ifdef RE_DIAG
 	/*
 	 * Perform hardware diagnostic on the original RTL8169.
@@ -1778,6 +1787,10 @@
 		bus_dma_tag_destroy(sc->rl_ldata.rl_stag);
 	}
 
+#ifdef DEV_NETMAP
+	netmap_detach(ifp);
+#endif /* DEV_NETMAP */
+
 	if (sc->rl_parent_tag)
 		bus_dma_tag_destroy(sc->rl_parent_tag);
 
@@ -1952,6 +1965,10 @@
 	    sc->rl_ldata.rl_tx_desc_cnt * sizeof(struct rl_desc));
 	for (i = 0; i < sc->rl_ldata.rl_tx_desc_cnt; i++)
 		sc->rl_ldata.rl_tx_desc[i].tx_m = NULL;
+#ifdef DEV_NETMAP
+	re_netmap_tx_init(sc);
+#endif /* DEV_NETMAP */
+
 	/* Set EOR. */
 	desc = &sc->rl_ldata.rl_tx_list[sc->rl_ldata.rl_tx_desc_cnt - 1];
 	desc->rl_cmdstat |= htole32(RL_TDESC_CMD_EOR);
@@ -1979,6 +1996,9 @@
 		if ((error = re_newbuf(sc, i)) != 0)
 			return (error);
 	}
+#ifdef DEV_NETMAP
+	re_netmap_rx_init(sc);
+#endif /* DEV_NETMAP */
 
 	/* Flush the RX descriptors */
 
@@ -2035,6 +2055,13 @@
 	RL_LOCK_ASSERT(sc);
 
 	ifp = sc->rl_ifp;
+#ifdef DEV_NETMAP
+	if (ifp->if_capenable & IFCAP_NETMAP) {
+		selwakeuppri(&NA(ifp)->rx_rings->si, PI_NET);
+		return 0;
+	}
+#endif /* DEV_NETMAP */
+
 	if (ifp->if_mtu > RL_MTU && (sc->rl_flags & RL_FLAG_JUMBOV2) != 0)
 		jumbo = 1;
 	else
@@ -2276,6 +2303,13 @@
 		return;
 
 	ifp = sc->rl_ifp;
+#ifdef DEV_NETMAP
+	if (ifp->if_capenable & IFCAP_NETMAP) {
+		selwakeuppri(&NA(ifp)->tx_rings[0].si, PI_NET);
+		return;
+	}
+#endif /* DEV_NETMAP */
+
 	/* Invalidate the TX descriptor list */
 	bus_dmamap_sync(sc->rl_ldata.rl_tx_list_tag,
 	    sc->rl_ldata.rl_tx_list_map,
@@ -2395,7 +2429,7 @@
 			CSR_WRITE_2(sc, RL_ISR, status);
 		if ((status & (RL_ISR_TX_OK | RL_ISR_TX_DESC_UNAVAIL)) &&
 		    (sc->rl_flags & RL_FLAG_PCIE))
-			CSR_WRITE_1(sc, sc->rl_txstart, RL_TXSTART_START);
+			CSR_WRITE_1(sc, sc->rl_txstart, RL_TXSTART_START << re_tx_hi);
 
 		/*
 		 * XXX check behaviour on receiver stalls.
@@ -2470,7 +2504,7 @@
 	 */
 	if ((status & (RL_ISR_TX_OK | RL_ISR_TX_DESC_UNAVAIL)) &&
 	    (sc->rl_flags & RL_FLAG_PCIE))
-		CSR_WRITE_1(sc, sc->rl_txstart, RL_TXSTART_START);
+		CSR_WRITE_1(sc, sc->rl_txstart, RL_TXSTART_START << re_tx_hi);
 	if (status & (
 #ifdef RE_TX_MODERATION
 	    RL_ISR_TIMEOUT_EXPIRED|
@@ -2562,7 +2596,7 @@
 	 */
 	if ((status & (RL_ISR_TX_OK | RL_ISR_TX_DESC_UNAVAIL)) &&
 	    (sc->rl_flags & RL_FLAG_PCIE))
-		CSR_WRITE_1(sc, sc->rl_txstart, RL_TXSTART_START);
+		CSR_WRITE_1(sc, sc->rl_txstart, RL_TXSTART_START << re_tx_hi);
 	if (status & (RL_ISR_TX_OK | RL_ISR_TX_ERR | RL_ISR_TX_DESC_UNAVAIL))
 		re_txeof(sc);
 
@@ -2794,6 +2828,21 @@
 
 	sc = ifp->if_softc;
 
+#ifdef DEV_NETMAP
+	if (ifp->if_capenable & IFCAP_NETMAP) {
+		struct netmap_kring *kring = &NA(ifp)->tx_rings[0];
+		if (sc->rl_ldata.rl_tx_prodidx != kring->nr_hwcur) {
+			/* kick the tx unit */
+			CSR_WRITE_1(sc, sc->rl_txstart, RL_TXSTART_START << re_tx_hi);
+			D("kick tx");
+#ifdef RE_TX_MODERATION
+			CSR_WRITE_4(sc, RL_TIMERCNT, 1);
+#endif
+			sc->rl_watchdog_timer = 5;
+		}
+		return;
+	}
+#endif /* DEV_NETMAP */
 	if ((ifp->if_drv_flags & (IFF_DRV_RUNNING | IFF_DRV_OACTIVE)) !=
 	    IFF_DRV_RUNNING || (sc->rl_flags & RL_FLAG_LINK) == 0)
 		return;
@@ -2835,7 +2884,7 @@
 	    sc->rl_ldata.rl_tx_list_map,
 	    BUS_DMASYNC_PREWRITE|BUS_DMASYNC_PREREAD);
 
-	CSR_WRITE_1(sc, sc->rl_txstart, RL_TXSTART_START);
+	CSR_WRITE_1(sc, sc->rl_txstart, RL_TXSTART_START << re_tx_hi);
 
 #ifdef RE_TX_MODERATION
 	/*
@@ -3044,10 +3093,22 @@
 	CSR_WRITE_4(sc, RL_RXLIST_ADDR_LO,
 	    RL_ADDR_LO(sc->rl_ldata.rl_rx_list_addr));
 
+    if (re_tx_hi) {
+#ifdef DEV_NETMAP
+	D("using hi priority list");
+#endif
+	CSR_WRITE_4(sc, RL_TXLIST_ADDR_HPRIO_HI,
+	    RL_ADDR_HI(sc->rl_ldata.rl_tx_list_addr));
+	CSR_WRITE_4(sc, RL_TXLIST_ADDR_HPRIO_LO,
+	    RL_ADDR_LO(sc->rl_ldata.rl_tx_list_addr));
+    } else {
+	CSR_WRITE_4(sc, RL_TXLIST_ADDR_HPRIO_HI, 0);
+	CSR_WRITE_4(sc, RL_TXLIST_ADDR_HPRIO_LO, 0);
 	CSR_WRITE_4(sc, RL_TXLIST_ADDR_HI,
 	    RL_ADDR_HI(sc->rl_ldata.rl_tx_list_addr));
 	CSR_WRITE_4(sc, RL_TXLIST_ADDR_LO,
 	    RL_ADDR_LO(sc->rl_ldata.rl_tx_list_addr));
+    }
 
 	/*
 	 * Enable transmit and receive.
@@ -3067,7 +3128,7 @@
 	} else
 		CSR_WRITE_4(sc, RL_TXCFG, RL_TXCFG_CONFIG);
 
-	CSR_WRITE_1(sc, RL_EARLY_TX_THRESH, 16);
+	CSR_WRITE_1(sc, RL_EARLY_TX_THRESH, re_tx_threshold); // XXX lower!
 
 	/*
 	 * Set the initial RX configuration.
@@ -3077,7 +3138,11 @@
 	/* Configure interrupt moderation. */
 	if (sc->rl_type == RL_8169) {
 		/* Magic from vendor. */
+#ifdef DEV_NETMAP
+		CSR_WRITE_2(sc, RL_INTRMOD, re_netmap_mitigation);
+#else
 		CSR_WRITE_2(sc, RL_INTRMOD, 0x5100);
+#endif
 	}
 
 #ifdef DEVICE_POLLING
Index: dev/bge/if_bge.c
===================================================================
--- dev/bge/if_bge.c	(revision 225462)
+++ dev/bge/if_bge.c	(working copy)
@@ -527,6 +527,10 @@
 #define	SPARC64_BLADE_2500_PATH_BGE	"/pci@1c,600000/network@3"
 #define	SPARC64_OFW_SUBVENDOR		"subsystem-vendor-id"
 
+#ifdef DEV_NETMAP
+#include <dev/netmap/if_bge_netmap.h>
+#endif
+
 static int
 bge_has_eaddr(struct bge_softc *sc)
 {
@@ -1103,6 +1107,10 @@
 		BGE_INC(sc->bge_std, BGE_STD_RX_RING_CNT);
 	}
 
+#ifdef DEV_NETMAP
+	bge_netmap_rx_init(sc);
+#endif /* DEV_NETMAP */
+
 	bus_dmamap_sync(sc->bge_cdata.bge_rx_std_ring_tag,
 	    sc->bge_cdata.bge_rx_std_ring_map, BUS_DMASYNC_PREWRITE);
 
@@ -1219,6 +1227,10 @@
 	sc->bge_tx_prodidx = 0;
 	bge_writembx(sc, BGE_MBX_TX_HOST_PROD0_LO, sc->bge_tx_prodidx);
 
+#ifdef DEV_NETMAP
+	bge_netmap_tx_init(sc);
+#endif /* DEV_NETMAP */
+
 	/* 5700 b2 errata */
 	if (sc->bge_chiprev == BGE_CHIPREV_5700_BX)
 		bge_writembx(sc, BGE_MBX_TX_HOST_PROD0_LO, sc->bge_tx_prodidx);
@@ -3275,6 +3287,9 @@
 	/* Tell upper layer we support long frames. */
 	ifp->if_data.ifi_hdrlen = sizeof(struct ether_vlan_header);
 
+#ifdef DEV_NETMAP
+	bge_netmap_attach(sc);
+#endif
 	/*
 	 * Hookup IRQ last.
 	 */
@@ -3347,6 +3362,10 @@
 		device_delete_child(dev, sc->bge_miibus);
 	}
 
+#ifdef DEV_NETMAP
+	netmap_detach(ifp);
+#endif /* DEV_NETMAP */
+
 	bge_release_resources(sc);
 
 	return (0);
@@ -3660,6 +3679,13 @@
 
 	rx_cons = sc->bge_rx_saved_considx;
 
+#ifdef DEV_NETMAP
+	if (sc->bge_ifp->if_capenable & IFCAP_NETMAP) {
+		selwakeuppri(&NA(sc->bge_ifp)->rx_rings->si, PI_NET);
+		return 0;
+	}
+#endif /* DEV_NETMAP */
+
 	/* Nothing to do. */
 	if (rx_cons == rx_prod)
 		return (rx_npkts);
@@ -3841,6 +3867,13 @@
 
 	BGE_LOCK_ASSERT(sc);
 
+#ifdef DEV_NETMAP
+	if (sc->bge_ifp->if_capenable & IFCAP_NETMAP) {
+		selwakeuppri(&NA(sc->bge_ifp)->tx_rings[0].si, PI_NET);
+		return;
+	}
+#endif /* DEV_NETMAP */
+
 	/* Nothing to do. */
 	if (sc->bge_tx_saved_considx == tx_cons)
 		return;
@@ -4611,6 +4644,19 @@
 	sc = ifp->if_softc;
 	BGE_LOCK_ASSERT(sc);
 
+#ifdef DEV_NETMAP
+	if (ifp->if_capenable & IFCAP_NETMAP) {
+		struct netmap_kring *kring = &NA(ifp)->tx_rings[0];
+		if (sc->bge_tx_prodidx != kring->nr_hwcur) {
+			D("called in netmap mode ? prod %d hwcur %d",
+				sc->bge_tx_prodidx, kring->nr_hwcur);
+			prodidx = kring->nr_hwcur;
+			goto kick_tx;
+		}
+		return;
+	}
+#endif /* DEV_NETMAP */
+		
 	if (!sc->bge_link ||
 	    (ifp->if_drv_flags & (IFF_DRV_RUNNING | IFF_DRV_OACTIVE)) !=
 	    IFF_DRV_RUNNING)
@@ -4676,6 +4722,9 @@
 	}
 
 	if (count > 0) {
+#ifdef DEV_NETMAP
+	    kick_tx:
+#endif /* DEV_NETMAP */
 		bus_dmamap_sync(sc->bge_cdata.bge_tx_ring_tag,
 		    sc->bge_cdata.bge_tx_ring_map, BUS_DMASYNC_PREWRITE);
 		/* Transmit. */
Index: dev/ixgbe/ixgbe.c
===================================================================
--- dev/ixgbe/ixgbe.c	(revision 225462)
+++ dev/ixgbe/ixgbe.c	(working copy)
@@ -313,6 +313,10 @@
 static int fdir_pballoc = 1;
 #endif
 
+#ifdef DEV_NETMAP
+#include <dev/netmap/ixgbe_netmap.h>
+#endif /* DEV_NETMAP */
+
 /*********************************************************************
  *  Device identification routine
  *
@@ -578,6 +582,9 @@
 
 	ixgbe_add_hw_stats(adapter);
 
+#ifdef DEV_NETMAP
+	ixgbe_netmap_attach(adapter);
+#endif /* DEV_NETMAP */
 	INIT_DEBUGOUT("ixgbe_attach: end");
 	return (0);
 err_late:
@@ -652,6 +659,9 @@
 
 	ether_ifdetach(adapter->ifp);
 	callout_drain(&adapter->timer);
+#ifdef DEV_NETMAP
+	netmap_detach(adapter->ifp);
+#endif /* DEV_NETMAP */
 	ixgbe_free_pci_resources(adapter);
 	bus_generic_detach(dev);
 	if_free(adapter->ifp);
@@ -1364,6 +1374,14 @@
 
 	++que->irqs;
 
+#ifdef LATENCY_TIMESTAMPS // XXX store a timestamp into ispare[]
+	/* take the timestamp whch marks the interrupt has come. */
+	if (adapter->ifp->if_dunit == 0) {
+		ixgbe_intr_ts0 = rdtsc();
+	} else {
+		ixgbe_intr_ts1 = rdtsc();
+	}
+#endif /* LATENCY_TIMESTAMPS */
 	more_rx = ixgbe_rxeof(que, adapter->rx_process_limit);
 
 	IXGBE_TX_LOCK(txr);
@@ -1700,6 +1718,7 @@
         	olinfo_status |= m_head->m_pkthdr.len <<
 		    IXGBE_ADVTXD_PAYLEN_SHIFT;
 
+	// XXX store a timestamp into the packet
 	i = txr->next_avail_desc;
 	for (j = 0; j < nsegs; j++) {
 		bus_size_t seglen;
@@ -1719,6 +1738,7 @@
 		if (++i == adapter->num_tx_desc)
 			i = 0;
 
+		// XXX should we sync each buffer ?
 		txbuf->m_head = NULL;
 		txbuf->eop_index = -1;
 	}
@@ -2813,6 +2833,10 @@
 	struct adapter *adapter = txr->adapter;
 	struct ixgbe_tx_buf *txbuf;
 	int i;
+#ifdef DEV_NETMAP
+	struct netmap_slot *slot = netmap_reset(NA(adapter->ifp),
+		NR_TX, txr->me, 0);
+#endif
 
 	/* Clear the old ring contents */
 	IXGBE_TX_LOCK(txr);
@@ -2832,6 +2856,13 @@
 			m_freem(txbuf->m_head);
 			txbuf->m_head = NULL;
 		}
+#ifdef DEV_NETMAP
+		if (slot) {
+			netmap_load_map(txr->txtag, txbuf->map,
+				NMB(slot), adapter->rx_mbuf_sz);
+			slot++;
+		}
+#endif /* DEV_NETMAP */
 		/* Clear the EOP index */
 		txbuf->eop_index = -1;
         }
@@ -3310,6 +3341,18 @@
 
 	mtx_assert(&txr->tx_mtx, MA_OWNED);
 
+#ifdef DEV_NETMAP
+	if (ifp->if_capenable & IFCAP_NETMAP) {
+		selwakeuppri(&NA(ifp)->tx_rings[txr->me].si, PI_NET);
+		IXGBE_TX_UNLOCK(txr);
+		IXGBE_CORE_LOCK(adapter);
+		selwakeuppri(&NA(ifp)->tx_rings[adapter->num_queues + 1].si, PI_NET);
+		IXGBE_CORE_UNLOCK(adapter);
+		IXGBE_TX_LOCK(txr); // the caller is supposed to own the lock
+		return (FALSE);
+	}
+#endif /* DEV_NETMAP */
+
 	if (txr->tx_avail == adapter->num_tx_desc) {
 		txr->queue_status = IXGBE_QUEUE_IDLE;
 		return FALSE;
@@ -3698,6 +3741,10 @@
 	bus_dma_segment_t	pseg[1], hseg[1];
 	struct lro_ctrl		*lro = &rxr->lro;
 	int			rsize, nsegs, error = 0;
+#ifdef DEV_NETMAP
+	struct netmap_slot *slot = netmap_reset(NA(rxr->adapter->ifp),
+				NR_RX, rxr->me, 0);
+#endif /* DEV_NETMAP */
 
 	adapter = rxr->adapter;
 	ifp = adapter->ifp;
@@ -3721,6 +3768,18 @@
 		struct mbuf	*mh, *mp;
 
 		rxbuf = &rxr->rx_buffers[j];
+#ifdef DEV_NETMAP
+		if (slot) {
+			netmap_load_map(rxr->ptag,
+					rxbuf->pmap, NMB(slot),
+					adapter->rx_mbuf_sz);
+			/* Update descriptor */
+			rxr->rx_base[j].read.pkt_addr =
+				htole64(vtophys(NMB(slot)));
+			slot++;
+			continue;
+		}
+#endif /* DEV_NETMAP */
 		/*
 		** Don't allocate mbufs if not
 		** doing header split, its wasteful
@@ -4148,6 +4207,25 @@
 
 	IXGBE_RX_LOCK(rxr);
 
+	// XXX store a timestamp into ispare[]
+#ifdef DEV_NETMAP
+#if NETMAP_LATENCY_TIMESTAMPS
+	if (adapter->ifp->if_dunit == 0) {
+		netmap_rdtsc(ixgbe_intr_ts0);
+	} else {
+		netmap_rdtsc(ixgbe_intr_ts1);
+	}
+	STATS_ADD(ixgbe_stats, ifp->if_dunit, rxr->me);
+#endif /* NETMAP_LATENCY_TIMESTAMPS */
+	if (ifp->if_capenable & IFCAP_NETMAP) {
+		selwakeuppri(&NA(ifp)->rx_rings[rxr->me].si, PI_NET);
+		IXGBE_RX_UNLOCK(rxr);
+		IXGBE_CORE_LOCK(adapter);
+		selwakeuppri(&NA(ifp)->rx_rings[adapter->num_queues + 1].si, PI_NET);
+		IXGBE_CORE_UNLOCK(adapter);
+		return (0);
+	}
+#endif /* DEV_NETMAP */
 	for (i = rxr->next_to_check; count != 0;) {
 		struct mbuf	*sendmp, *mh, *mp;
 		u32		rsc, ptype;
