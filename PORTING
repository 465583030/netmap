# $Id$

Adding netmap support to network device drivers
------------------------------------------------

Netmap requires some small modifications to device drivers
to support the new API. You will need to add small patches
in 3-4 places in the original source, and implement typically
5 new functions.

* Patches:
  + in the initial part of the source, after the device-specific
    headers and prototypes have been declared, add the following
    <pre>
	+#if defined(DEV_NETMAP) || defined(CONFIG_NETMAP) || defined(CONFIG_NETMAP_MODULE)
	+#include <dev/netmap/if_re_netmap.h>
	+#endif /* !DEV_NETMAP */
    </pre>
    The place is typically ... in FreeBSD, and
    ... on Linux.

    The header really contains the new functions that implement
    the netmap API. Including them inline simplifies the building
    as it does not require to insert additional dependencies in the
    build system.

    On FreeBSD DEV_NETMAP is sufficient to detect whether netmap extensions
    should be compiled in, whereas CONFIG_NETMAP and CONFIG_NETMAP_MODULE
    are the Linux equivalent.

    If a driver is made of multiple source files, you will need to include
    the additional header in all the (few) patched files, preferably using
    a macro such as NETMAP_FOO_MAIN to indicate the file where the
    new functions should be compiled in.

  + after the tx/rx rings have been initialized, add a patch like this:
    <pre>
	+#ifdef DEV_NETMAP
	+	foo_netmap_init(priv);
	+#endif /* DEV_NETMAP */
    </pre>
    The argument is typically the private device descriptor, or even
    the struct ifnet/net_device.

  + in the interrupt dispatch routines, something like
    <pre>
	+#ifdef DEV_NETMAP
	+       int dummy;
	+       if (netmap_rx_irq(adapter->netdev, rx_ring->queue_index, &dummy))
	+               return true;
	+#endif /* DEV_NETMAP */
	...
	+#ifdef DEV_NETMAP
	+       if (netmap_tx_irq(adapter->netdev, tx_ring->queue_index))
	+               return true; /* seems to be ignored */
	+#endif /* DEV_NETMAP */
     </pre>
     to skip the normal processing and instead wake up the process in
     charge of doing I/O
