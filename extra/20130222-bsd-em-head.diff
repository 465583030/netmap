Index: head/release/picobsd/floppy.tree/etc/ttys
===================================================================
--- head/release/picobsd/floppy.tree/etc/ttys	(revision 247068)
+++ head/release/picobsd/floppy.tree/etc/ttys	(working copy)
@@ -8,6 +8,7 @@
 # This entry needed for asking password when init goes to single-user mode
 # If you want to be asked for password, change "secure" to "insecure" here
 #console	none				unknown	off secure
+console "/usr/libexec/getty std.9600" vt100 on secure
 vga	none				xterm	off secure
 #
 ttyv0	"/usr/libexec/getty Pc"		xterm	on  secure
Index: head/sys/dev/e1000/if_em.h
===================================================================
--- head/sys/dev/e1000/if_em.h	(revision 247068)
+++ head/sys/dev/e1000/if_em.h	(working copy)
@@ -271,6 +271,28 @@
 	int value;			/* Current value in usecs */
 };
 
+#ifdef PARAVIRT
+#define	E1000_PARA_SUBDEV	0x1101		/* special id */
+#define	E1000_CSBAL		0x02830		/* csb physical address */
+#define	E1000_CSBAH		0x02834
+struct e1000_csb {				/* comm. block */
+	uint32_t	guest_tdt;		/* signals from guest */
+	uint32_t	guest_need_txkick;	/* out of tx bufs */
+	uint32_t	guest_need_rxkick;	/* out of rx bufs */
+	uint32_t	guest_csb_on;		/* mode enabled on the guest */
+	uint32_t	guest_rdt;		/* signals from guest */
+	uint32_t	pad[11];		/* to 64 bytes */
+
+	uint32_t	host_tdh;		/* mirror tdh, unused */
+	uint32_t	host_need_txkick;	/* enable mode */
+	uint32_t	host_txcycles_lim;	/* cycles before stop bh */
+	uint32_t	host_txcycles;		/* current bh cycles */
+	uint32_t	host_rdh;		/* mirror rdh, unused */
+	uint32_t	host_need_rxkick;	/* ??? */
+
+};
+#endif /* PARAVIRT */
+
 /*
  * The transmit ring, one per tx queue
  */
@@ -429,6 +451,7 @@
 	struct em_int_delay_info tx_abs_int_delay;
 	struct em_int_delay_info rx_int_delay;
 	struct em_int_delay_info rx_abs_int_delay;
+	struct em_int_delay_info tx_itr;
 
 	/* Misc stats maintained by the driver */
 	unsigned long	dropped_pkts;
@@ -440,6 +463,24 @@
 	unsigned long	watchdog_events;
 	unsigned long	link_irq;
 
+#ifdef MITIGATION
+	/* 0 = idle; 1xxxx int-pending; 3xxxx int + d pending + tdt */
+#define MIT_PENDING_INT	0x10000	/* pending interrupt */
+#define MIT_PENDING_TDT	0x30000	/* both intr and tdt write are pending */
+	uint32_t shadow_tdt;
+	uint32_t mit_enable;
+	uint32_t rx_retries;	/* optimize rx loop */
+#endif /* MITIGATION */
+
+#ifdef PARAVIRT
+	struct em_dma_alloc	csb_mem;	/* phys address */
+	struct e1000_csb	*csb;		/* virtual addr */
+	uint32_t		tdt_csb_count;// XXX stat
+	uint32_t		tdt_reg_count;// XXX stat
+	uint32_t		tdt_int_count;// XXX stat
+	uint32_t		guest_need_kick_count;// XXX stat
+#endif /* PARAVIRT */
+
 	struct e1000_hw_stats stats;
 };
 
Index: head/sys/dev/e1000/if_lem.c
===================================================================
--- head/sys/dev/e1000/if_lem.c	(revision 247068)
+++ head/sys/dev/e1000/if_lem.c	(working copy)
@@ -32,6 +32,9 @@
 ******************************************************************************/
 /*$FreeBSD$*/
 
+#define LEM_SEND_COMBINING
+#define LEM_PARAVIRT	/* enable virtio-like synchronization */
+
 #ifdef HAVE_KERNEL_OPTION_HEADERS
 #include "opt_device_polling.h"
 #include "opt_inet.h"
@@ -281,12 +284,15 @@
 #define EM_TICKS_TO_USECS(ticks)	((1024 * (ticks) + 500) / 1000)
 #define EM_USECS_TO_TICKS(usecs)	((1000 * (usecs) + 512) / 1024)
 
+#define MAX_INTS_PER_SEC	8000
+#define DEFAULT_ITR	     1000000000/(MAX_INTS_PER_SEC * 256)
+
 static int lem_tx_int_delay_dflt = EM_TICKS_TO_USECS(EM_TIDV);
 static int lem_rx_int_delay_dflt = EM_TICKS_TO_USECS(EM_RDTR);
 static int lem_tx_abs_int_delay_dflt = EM_TICKS_TO_USECS(EM_TADV);
 static int lem_rx_abs_int_delay_dflt = EM_TICKS_TO_USECS(EM_RADV);
-static int lem_rxd = EM_DEFAULT_RXD;
-static int lem_txd = EM_DEFAULT_TXD;
+static int lem_rxd = 8*EM_DEFAULT_RXD;
+static int lem_txd = 8*EM_DEFAULT_TXD;
 static int lem_smart_pwr_down = FALSE;
 
 /* Controls whether promiscuous also shows bad packets */
@@ -442,6 +448,11 @@
 		    &adapter->tx_abs_int_delay,
 		    E1000_REGISTER(&adapter->hw, E1000_TADV),
 		    lem_tx_abs_int_delay_dflt);
+		lem_add_int_delay_sysctl(adapter, "itr",
+		    "interrupt delay limit in usecs/4",
+		    &adapter->tx_itr,
+		    E1000_REGISTER(&adapter->hw, E1000_ITR),
+		    DEFAULT_ITR);
 	}
 
 	/* Sysctls for limiting the amount of work done in the taskqueue */
@@ -449,6 +460,14 @@
 	    "max number of rx packets to process", &adapter->rx_process_limit,
 	    lem_rx_process_limit);
 
+#ifdef LEM_SEND_COMBINING
+	/* Sysctls to control mitigation */
+	lem_add_rx_process_limit(adapter, "tx_sc",
+	    "tx send combining", &adapter->tx_sc_on, 0);
+	lem_add_rx_process_limit(adapter, "rx_retries",
+	    "driver rx retries", &adapter->rx_retries, 0);
+#endif /* LEM_SEND_COMBINING */
+
         /* Sysctl for setting the interface flow control */
 	lem_set_flow_cntrl(adapter, "flow_control",
 	    "flow control setting",
@@ -506,6 +525,46 @@
 	 */
 	adapter->hw.mac.report_tx_early = 1;
 
+#ifdef LEM_PARAVIRT
+	if (adapter->hw.subsystem_device_id == E1000_PARA_SUBDEV) {
+		uint64_t bus_addr;
+
+		device_printf(dev, "paravirt support on dev %p\n", adapter);
+		tsize = 4096; // XXX one page for the csb
+		if (lem_dma_malloc(adapter, tsize, &adapter->csb_mem, BUS_DMA_NOWAIT)) {
+			device_printf(dev, "Unable to allocate csb memory\n");
+			error = ENOMEM;
+			goto err_csb;
+		}
+		/* Setup the Base of the CSB */
+		adapter->csb = (struct e1000_csb *)adapter->csb_mem.dma_vaddr;
+		/* force the first kick */
+		adapter->csb->host_need_txkick = 1; /* txring empty */
+		adapter->csb->guest_need_rxkick = 1; /* no rx packets */
+		bus_addr = adapter->csb_mem.dma_paddr;
+		lem_add_rx_process_limit(adapter, "csb_on",
+		    "enable paravirt.", &adapter->csb->guest_csb_on, 0);
+		lem_add_rx_process_limit(adapter, "txc_lim",
+		    "txc_lim", &adapter->csb->host_txcycles_lim, 1);
+		/* some stats */
+#define PA_SC(name, var, val)		\
+	lem_add_rx_process_limit(adapter, name, name, var, val)
+		PA_SC("host_need_txkick",&adapter->csb->host_need_txkick, 1);
+		PA_SC("host_need_rxkick",&adapter->csb->host_need_rxkick, 1);
+		PA_SC("guest_need_txkick",&adapter->csb->guest_need_txkick, 0);
+		PA_SC("guest_need_rxkick",&adapter->csb->guest_need_rxkick, 1);
+		PA_SC("tdt_reg_count",&adapter->tdt_reg_count, 0);
+		PA_SC("tdt_csb_count",&adapter->tdt_csb_count, 0);
+		PA_SC("tdt_int_count",&adapter->tdt_int_count, 0);
+		PA_SC("guest_need_kick_count",&adapter->guest_need_kick_count, 0);
+		/* tell the host where the block is */
+		E1000_WRITE_REG(&adapter->hw, E1000_CSBAH,
+			(u32)(bus_addr >> 32));
+		E1000_WRITE_REG(&adapter->hw, E1000_CSBAL,
+			(u32)bus_addr);
+	}
+#endif /* LEM_PARAVIRT */
+
 	tsize = roundup2(adapter->num_tx_desc * sizeof(struct e1000_tx_desc),
 	    EM_DBA_ALIGN);
 
@@ -664,6 +723,11 @@
 err_rx_desc:
 	lem_dma_free(adapter, &adapter->txdma);
 err_tx_desc:
+#ifdef LEM_PARAVIRT
+	lem_dma_free(adapter, &adapter->csb_mem);
+err_csb:
+#endif /* LEM_PARAVIRT */
+
 err_pci:
 	if (adapter->ifp != NULL)
 		if_free(adapter->ifp);
@@ -751,6 +815,12 @@
 		adapter->rx_desc_base = NULL;
 	}
 
+#ifdef LEM_PARAVIRT
+	if (adapter->csb) {
+		lem_dma_free(adapter, &adapter->csb_mem);
+		adapter->csb = NULL;
+	}
+#endif /* LEM_PARAVIRT */
 	lem_release_hw_control(adapter);
 	free(adapter->mta, M_DEVBUF);
 	EM_TX_LOCK_DESTROY(adapter);
@@ -860,6 +930,15 @@
 	}
 	if (adapter->num_tx_desc_avail <= EM_TX_OP_THRESHOLD)
 		ifp->if_drv_flags |= IFF_DRV_OACTIVE;
+#ifdef LEM_PARAVIRT
+	if (ifp->if_drv_flags & IFF_DRV_OACTIVE && adapter->csb &&
+	    adapter->csb->guest_csb_on && !adapter->csb->guest_need_txkick) {
+		adapter->csb->guest_need_txkick = 1;
+		adapter->guest_need_kick_count++;
+		// XXX memory barrier
+		lem_txeof(adapter); // XXX possibly clear IFF_DRV_OACTIVE
+	}
+#endif /* LEM_PARAVIRT */
 
 	return;
 }
@@ -1300,6 +1379,7 @@
 	lem_rxeof(adapter, -1, NULL);
 
 	EM_TX_LOCK(adapter);
+	adapter->tdt_int_count++;
 	lem_txeof(adapter);
 	if (ifp->if_drv_flags & IFF_DRV_RUNNING &&
 	    !IFQ_DRV_IS_EMPTY(&ifp->if_snd))
@@ -1337,12 +1417,17 @@
 
 
 	if (ifp->if_drv_flags & IFF_DRV_RUNNING) {
-		lem_rxeof(adapter, adapter->rx_process_limit, NULL);
+		bool more = lem_rxeof(adapter, adapter->rx_process_limit, NULL);
 		EM_TX_LOCK(adapter);
+		adapter->tdt_int_count++;
 		lem_txeof(adapter);
 		if (!IFQ_DRV_IS_EMPTY(&ifp->if_snd))
 			lem_start_locked(ifp);
 		EM_TX_UNLOCK(adapter);
+		if (more) {
+			taskqueue_enqueue(adapter->tq, &adapter->rxtx_task);
+			return;
+		}
 	}
 
 	if (ifp->if_drv_flags & IFF_DRV_RUNNING)
@@ -1702,6 +1787,35 @@
 	 */
 	bus_dmamap_sync(adapter->txdma.dma_tag, adapter->txdma.dma_map,
 	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
+
+#ifdef LEM_PARAVIRT
+	if (adapter->csb) {
+		adapter->csb->guest_tdt = i;
+		/* XXX memory barrier ? */
+ 		if (adapter->csb->guest_csb_on &&
+		    !adapter->csb->host_need_txkick) {
+			if (adapter->num_tx_desc_avail <= 64) {// XXX
+				lem_txeof(adapter);
+			}
+			adapter->tdt_csb_count++;
+			return (0);
+		}
+	}
+#endif /* LEM_PARAVIRT */
+
+#ifdef LEM_SEND_COMBINING
+	if (adapter->tx_sc_on) {
+		if (adapter->shadow_tdt & MIT_PENDING_INT) {
+			/* signal intr and data pending */
+			adapter->shadow_tdt = MIT_PENDING_TDT | (i & 0xffff);
+			return (0);
+		} else {
+			adapter->shadow_tdt = MIT_PENDING_INT;
+		}
+	}
+	adapter->tdt_reg_count++;
+#endif /* LEM_SEND_COMBINING */
+
 	if (adapter->hw.mac.type == e1000_82547 &&
 	    adapter->link_duplex == HALF_DUPLEX)
 		lem_82547_move_tail(adapter);
@@ -1957,6 +2071,16 @@
 
 	lem_smartspeed(adapter);
 
+#ifdef LEM_PARAVIRT
+	/* recover space if needed */
+	if (adapter->csb && adapter->csb->guest_csb_on &&
+	    (adapter->watchdog_check == TRUE) &&
+	    (ticks - adapter->watchdog_time > EM_WATCHDOG) &&
+	    (adapter->num_tx_desc_avail != adapter->num_tx_desc) ) {
+		lem_txeof(adapter);
+		/* XXX should also recover from stalls ? */
+	}
+#endif /* LEM_PARAVIRT */
 	/*
 	 * We check the watchdog: the time since
 	 * the last TX descriptor was cleaned.
@@ -3027,6 +3151,16 @@
         adapter->next_tx_to_clean = first;
         adapter->num_tx_desc_avail = num_avail;
 
+#ifdef LEM_SEND_COMBINING
+	if ((adapter->shadow_tdt & MIT_PENDING_TDT) == MIT_PENDING_TDT) {
+		/* a tdt write is pending, do it */
+		E1000_WRITE_REG(&adapter->hw, E1000_TDT(0),
+			0xffff & adapter->shadow_tdt);
+		adapter->shadow_tdt = MIT_PENDING_INT;
+	} else {
+		adapter->shadow_tdt = 0; // disable
+	}
+#endif /* LEM_SEND_COMBINING */
         /*
          * If we have enough room, clear IFF_DRV_OACTIVE to
          * tell the stack that it is OK to send packets.
@@ -3034,6 +3168,12 @@
          */
         if (adapter->num_tx_desc_avail > EM_TX_CLEANUP_THRESHOLD) {                
                 ifp->if_drv_flags &= ~IFF_DRV_OACTIVE;
+#ifdef LEM_LEM_PARAVIRT
+		if (adapter->csb) {
+			adapter->csb->guest_need_txkick = 0;
+			// XXX memory barrier
+		}
+#endif /* LEM_LEM_PARAVIRT */
                 if (adapter->num_tx_desc_avail == adapter->num_tx_desc) {
 			adapter->watchdog_check = FALSE;
 			return;
@@ -3246,8 +3386,6 @@
  *  Enable receive unit.
  *
  **********************************************************************/
-#define MAX_INTS_PER_SEC	8000
-#define DEFAULT_ITR	     1000000000/(MAX_INTS_PER_SEC * 256)
 
 static void
 lem_initialize_receive_unit(struct adapter *adapter)
@@ -3347,9 +3485,16 @@
 
 		if (t >= na->num_rx_desc)
 			t -= na->num_rx_desc;
+#ifdef LEM_PARAVIRT
+		adapter->csb->guest_rdt = t;
+#endif /* LEM_PARAVIRT */
 		E1000_WRITE_REG(&adapter->hw, E1000_RDT(0), t);
-	} else
+		return;
+	}
 #endif /* DEV_NETMAP */
+#ifdef LEM_PARAVIRT
+	adapter->csb->guest_rdt = adapter->num_rx_desc - 1;
+#endif /* LEM_PARAVIRT */
 	E1000_WRITE_REG(&adapter->hw, E1000_RDT(0), adapter->num_rx_desc - 1);
 
 	return;
@@ -3426,7 +3571,12 @@
 	u16 		len, desc_len, prev_len_adj;
 	int		i, rx_sent = 0;
 	struct e1000_rx_desc   *current_desc;
+	int retries;
 
+#ifdef LEM_PARAVIRT
+	ND("clear guest_rxkick at %d", adapter->next_rx_desc_to_check);
+	adapter->csb->guest_need_rxkick = 0;
+#endif /* LEM_PARAVIRT */
 	EM_RX_LOCK(adapter);
 	i = adapter->next_rx_desc_to_check;
 	current_desc = &adapter->rx_desc_base[i];
@@ -3443,19 +3593,39 @@
 	}
 #endif /* DEV_NETMAP */
 
+#if 0 // XXX optimization ?
 	if (!((current_desc->status) & E1000_RXD_STAT_DD)) {
 		if (done != NULL)
 			*done = rx_sent;
 		EM_RX_UNLOCK(adapter);
 		return (FALSE);
 	}
+#endif /* 0 */
 
+	retries = 0;
 	while (count != 0 && ifp->if_drv_flags & IFF_DRV_RUNNING) {
 		struct mbuf *m = NULL;
 
 		status = current_desc->status;
-		if ((status & E1000_RXD_STAT_DD) == 0)
+		if ((status & E1000_RXD_STAT_DD) == 0) {
+			if (++retries <= adapter->rx_retries) {
+				continue;
+			}
+#ifdef LEM_PARAVIRT
+			if (adapter->csb->guest_need_rxkick == 0) {
+				ND("set guest_rxkick at %d", adapter->next_rx_desc_to_check);
+				adapter->csb->guest_need_rxkick = 1;
+				continue;
+			}
+#endif /* LEM_PARAVIRT */
 			break;
+		}
+#ifdef LEM_PARAVIRT
+		if (adapter->csb->guest_need_rxkick)
+			ND("clear again guest_rxkick at %d", adapter->next_rx_desc_to_check);
+		adapter->csb->guest_need_rxkick = 0;
+#endif /* LEM_PARAVIRT */
+		retries = 0;
 
 		mp = adapter->rx_buffer_area[i].m_head;
 		/*
@@ -3599,6 +3769,10 @@
 	/* Advance the E1000's Receive Queue #0  "Tail Pointer". */
 	if (--i < 0)
 		i = adapter->num_rx_desc - 1;
+#ifdef LEM_PARAVIRT
+	adapter->csb->guest_rdt = i;
+	if (!adapter->csb->guest_csb_on || adapter->csb->host_need_rxkick)
+#endif /* LEM_PARAVIRT */
 	E1000_WRITE_REG(&adapter->hw, E1000_RDT(0), i);
 	if (done != NULL)
 		*done = rx_sent;
@@ -4584,6 +4758,8 @@
 		return (EINVAL);
 	info->value = usecs;
 	ticks = EM_USECS_TO_TICKS(usecs);
+	if (info->offset == E1000_ITR)	/* units are 256ns here */
+		ticks *= 4;
 
 	adapter = info->adapter;
 	
Index: head/sys/dev/e1000/if_lem.h
===================================================================
--- head/sys/dev/e1000/if_lem.h	(revision 247068)
+++ head/sys/dev/e1000/if_lem.h	(working copy)
@@ -265,6 +265,28 @@
 #define PICOSECS_PER_TICK	20833
 #define TSYNC_PORT		319 /* UDP port for the protocol */
 
+#ifdef PARAVIRT
+#define	E1000_PARA_SUBDEV	0x1101		/* special id */
+#define	E1000_CSBAL		0x02830		/* csb physical address */
+#define	E1000_CSBAH		0x02834
+struct e1000_csb {				/* comm. block */
+	uint32_t	guest_tdt;		/* signals from guest */
+	uint32_t	guest_need_txkick;	/* out of tx bufs */
+	uint32_t	guest_need_rxkick;	/* out of rx bufs */
+	uint32_t	guest_csb_on;		/* mode enabled on the guest */
+	uint32_t	guest_rdt;		/* signals from guest */
+	uint32_t	pad[11];		/* to 64 bytes */
+
+	uint32_t	host_tdh;		/* mirror tdh, unused */
+	uint32_t	host_need_txkick;	/* enable mode */
+	uint32_t	host_txcycles_lim;	/* cycles before stop bh */
+	uint32_t	host_txcycles;		/* current bh cycles */
+	uint32_t	host_rdh;		/* mirror rdh, unused */
+	uint32_t	host_need_rxkick;	/* ??? */
+
+};
+#endif /* PARAVIRT */
+
 /*
  * Bus dma allocation structure used by
  * e1000_dma_malloc and e1000_dma_free.
@@ -363,6 +385,7 @@
 	struct em_int_delay_info tx_abs_int_delay;
 	struct em_int_delay_info rx_int_delay;
 	struct em_int_delay_info rx_abs_int_delay;
+	struct em_int_delay_info tx_itr;
 
 	/*
 	 * Transmit definitions
@@ -436,7 +459,24 @@
 	boolean_t       pcix_82544;
 	boolean_t       in_detach;
 
+#ifdef LEM_SEND_COMBINING
+	/* 0 = idle; 1xxxx int-pending; 3xxxx int + d pending + tdt */
+#define MIT_PENDING_INT	0x10000	/* pending interrupt */
+#define MIT_PENDING_TDT	0x30000	/* both intr and tdt write are pending */
+	uint32_t shadow_tdt;
+	uint32_t tx_sc_on;
+	uint32_t rx_retries;	/* optimize rx loop */
+#endif /* LEM_SEND_COMBINING */
 
+#ifdef LEM_PARAVIRT
+	struct em_dma_alloc	csb_mem;	/* phys address */
+	struct e1000_csb	*csb;		/* virtual addr */
+	uint32_t		tdt_csb_count;// XXX stat
+	uint32_t		tdt_reg_count;// XXX stat
+	uint32_t		tdt_int_count;// XXX stat
+	uint32_t		guest_need_kick_count;// XXX stat
+#endif /* LEM_PARAVIRT */
+
 	struct e1000_hw_stats stats;
 };
 
Index: head/tools/tools/netrate/netsend/netsend.c
===================================================================
--- head/tools/tools/netrate/netsend/netsend.c	(revision 247068)
+++ head/tools/tools/netrate/netsend/netsend.c	(working copy)
@@ -49,6 +49,7 @@
 	int ipv6;
 	struct timespec interval;
 	int port, port_max;
+	int burst;
 	long duration;
 	struct sockaddr_in sin;
 	struct sockaddr_in6 sin6;
@@ -164,8 +165,8 @@
 		 * calls, but also make sure there is at least one every
 		 * some 100 packets.
 		 */
-	if ((long)ns < minres_ns/100)
-		gettimeofday_cycles = 100;
+	if ((long)ns < minres_ns/a->burst)
+		gettimeofday_cycles = a->burst;
 	else
 		gettimeofday_cycles = minres_ns/ns;
 	fprintf(stderr,
@@ -288,7 +289,7 @@
 
 	bzero(&a, sizeof(a));
 
-	if (argc != 6)
+	if (argc < 6)
 		usage();
 
 	memset(&hints, 0, sizeof(hints));
@@ -360,6 +361,11 @@
 	if (a.duration < 0 || *dummy != '\0')
 		usage();
 
+	if (argc > 6)
+		a.burst = strtoul(argv[6], NULL, 0);
+	if (a.burst < 1 || a.burst > 10000)
+		a.burst = 100;
+
 	a.packet = malloc(payloadsize);
 	if (a.packet == NULL) {
 		perror("malloc");
