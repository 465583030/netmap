Index: ../head/sys/dev/e1000/if_lem.c
===================================================================
--- ../head/sys/dev/e1000/if_lem.c	(revision 242412)
+++ ../head/sys/dev/e1000/if_lem.c	(working copy)
@@ -32,6 +32,8 @@
 ******************************************************************************/
 /*$FreeBSD$*/
 
+#define MITIGATION
+
 #ifdef HAVE_KERNEL_OPTION_HEADERS
 #include "opt_device_polling.h"
 #include "opt_inet.h"
@@ -281,6 +283,9 @@
 #define EM_TICKS_TO_USECS(ticks)	((1024 * (ticks) + 500) / 1000)
 #define EM_USECS_TO_TICKS(usecs)	((1000 * (usecs) + 512) / 1024)
 
+#define MAX_INTS_PER_SEC	8000
+#define DEFAULT_ITR	     1000000000/(MAX_INTS_PER_SEC * 256)
+
 static int lem_tx_int_delay_dflt = EM_TICKS_TO_USECS(EM_TIDV);
 static int lem_rx_int_delay_dflt = EM_TICKS_TO_USECS(EM_RDTR);
 static int lem_tx_abs_int_delay_dflt = EM_TICKS_TO_USECS(EM_TADV);
@@ -442,6 +447,11 @@
 		    &adapter->tx_abs_int_delay,
 		    E1000_REGISTER(&adapter->hw, E1000_TADV),
 		    lem_tx_abs_int_delay_dflt);
+		lem_add_int_delay_sysctl(adapter, "itr",
+		    "interrupt delay limit in usecs/4",
+		    &adapter->tx_itr,
+		    E1000_REGISTER(&adapter->hw, E1000_ITR),
+		    DEFAULT_ITR);
 	}
 
 	/* Sysctls for limiting the amount of work done in the taskqueue */
@@ -1702,6 +1712,15 @@
 	 */
 	bus_dmamap_sync(adapter->txdma.dma_tag, adapter->txdma.dma_map,
 	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
+#ifdef MITIGATION
+	adapter->shadow_tdt = i;
+	if (adapter->tx_intr_pending) {
+		adapter->tx_data_pending = 1;
+		return (0);
+	}
+	adapter->tx_intr_pending = 1;
+	adapter->tx_data_pending = 0;
+#endif /* MITIGATION */
 	if (adapter->hw.mac.type == e1000_82547 &&
 	    adapter->link_duplex == HALF_DUPLEX)
 		lem_82547_move_tail(adapter);
@@ -3027,6 +3046,13 @@
         adapter->next_tx_to_clean = first;
         adapter->num_tx_desc_avail = num_avail;
 
+#ifdef MITIGATION
+	adapter->tx_intr_pending = 0;
+	if (adapter->tx_data_pending) {
+		adapter->tx_data_pending = 0;
+		E1000_WRITE_REG(&adapter->hw, E1000_TDT(0), adapter->shadow_tdt);
+	}
+#endif /* MITIGATION */
         /*
          * If we have enough room, clear IFF_DRV_OACTIVE to
          * tell the stack that it is OK to send packets.
@@ -3246,8 +3272,6 @@
  *  Enable receive unit.
  *
  **********************************************************************/
-#define MAX_INTS_PER_SEC	8000
-#define DEFAULT_ITR	     1000000000/(MAX_INTS_PER_SEC * 256)
 
 static void
 lem_initialize_receive_unit(struct adapter *adapter)
@@ -4588,6 +4612,8 @@
 		return (EINVAL);
 	info->value = usecs;
 	ticks = EM_USECS_TO_TICKS(usecs);
+	if (info->offset == E1000_ITR)	/* units are 256ns here */
+		ticks *= 4;
 
 	adapter = info->adapter;
 	
Index: ../head/sys/dev/e1000/if_lem.h
===================================================================
--- ../head/sys/dev/e1000/if_lem.h	(revision 242412)
+++ ../head/sys/dev/e1000/if_lem.h	(working copy)
@@ -364,6 +364,12 @@
 	struct em_int_delay_info rx_int_delay;
 	struct em_int_delay_info rx_abs_int_delay;
 
+#ifdef MITIGATION
+	uint32_t shadow_tdt;
+	uint32_t tx_intr_pending; // we have a pending interrupt
+	uint32_t tx_data_pending; // need to actually transmit
+	struct em_int_delay_info tx_itr;
+#endif /* MITIGATION */
 	/*
 	 * Transmit definitions
 	 *
