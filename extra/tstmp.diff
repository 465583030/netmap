Index: dev/netmap/netmap.c
===================================================================
--- dev/netmap/netmap.c	(revision 258360)
+++ dev/netmap/netmap.c	(working copy)
@@ -2656,6 +2656,7 @@
 	 */
 	for (i = priv->np_qfirst; want_rx && i < lim_rx; i++) {
 		kring = &na->rx_rings[i];
+		TSTMP(1, i, kring->ring->cur, kring->ring->avail,0,0);
 		if (kring->ring->avail > 0) {
 			revents |= want_rx;
 			want_rx = 0;	/* also breaks the loop */
@@ -2663,6 +2664,7 @@
 	}
 	for (i = priv->np_qfirst; want_tx && i < lim_tx; i++) {
 		kring = &na->tx_rings[i];
+		TSTMP(2, i, kring->ring->cur, kring->ring->avail,0,0);
 		if (kring->ring->avail > 0) {
 			revents |= want_tx;
 			want_tx = 0;	/* also breaks the loop */
@@ -2705,6 +2707,7 @@
 				revents |= POLLERR;
 
 			/* Check avail/call selrecord only if called with POLLOUT */
+			TSTMP(2, i, kring->ring->cur, kring->ring->avail,0,1);
 			if (want_tx) {
 				if (kring->ring->avail > 0) {
 					/* stop at the first ring. We don't risk
Index: kern/subr_smp.c
===================================================================
--- kern/subr_smp.c	(revision 258360)
+++ kern/subr_smp.c	(working copy)
@@ -132,7 +132,63 @@
 }
 SYSINIT(cpu_mp_setmaxid, SI_SUB_TUNABLES, SI_ORDER_FIRST, mp_setmaxid, NULL);
 
+#ifdef KERN_TIMESTAMP
 /*
+ * allocate 1M entries, 32 bytes each.
+ * We then split it among available CPUs.
+ */
+#define KERN_TIMESTAMP_SIZE	(1<<20)
+struct ktstmp_buf_t { uint32_t d[8]; };
+/* write positions in the buffer */
+static int ktstmp_index[MAXCPU];
+
+/* the buffers */
+static struct ktstmp_buf_t ktstmp_buf[KERN_TIMESTAMP_SIZE];
+static int ktstmp_range;
+
+SYSCTL_NODE(_kern, OID_AUTO, ts, CTLFLAG_RD, 0, "TS buffers");
+SYSCTL_OPAQUE(_kern_ts, OID_AUTO, idx, CTLFLAG_RD, ktstmp_index,
+	sizeof(ktstmp_index), "LU", "Timestamp indexes");
+
+SYSCTL_OPAQUE(_kern_ts, OID_AUTO, data, CTLFLAG_RD, ktstmp_buf,
+	sizeof(ktstmp_buf), "LU", "Timestamp buffers");
+
+void _TSTMP(uint32_t p[8])
+{
+	int i, pos;
+	i = curcpu;
+	pos = ktstmp_index[i]++;
+	if (pos == ktstmp_range - 1)
+		ktstmp_index[i] = 0;
+	ktstmp_buf[pos + ktstmp_range * i] = *(struct ktstmp_buf_t *)p;
+}
+
+static void
+tstmp_init(void *dummy)
+{
+	int i;
+
+	ktstmp_range = KERN_TIMESTAMP_SIZE / mp_ncpus;
+
+	for (i = 0; i < mp_ncpus; i++) {
+		struct sysctl_oid *tree;
+		char namebuf[4];
+		snprintf(namebuf, sizeof(namebuf), "%d", i);
+printf("added child %d\n", i);
+		tree = SYSCTL_ADD_NODE(NULL, SYSCTL_STATIC_CHILDREN(_kern_ts),
+			OID_AUTO, namebuf, CTLFLAG_RD, NULL, "Id");
+		SYSCTL_ADD_INT(NULL, SYSCTL_CHILDREN(tree), OID_AUTO, "idx",
+			CTLFLAG_RD, &ktstmp_index[i], 1, "I-th index");
+		SYSCTL_ADD_OPAQUE(NULL, SYSCTL_CHILDREN(tree), OID_AUTO, "data",
+			CTLFLAG_RD, &ktstmp_buf[i*ktstmp_range],
+			sizeof(struct ktstmp_buf_t) * ktstmp_range,
+			"LU", "I-th buffer");
+	}
+}
+SYSINIT(cpu_mp_ts, SI_SUB_CPU, SI_ORDER_ANY, tstmp_init, NULL);
+#endif /* KERN_TIMESTAMP */
+
+/*
  * Call the MD SMP initialization code.
  */
 static void
Index: sys/param.h
===================================================================
--- sys/param.h	(revision 258360)
+++ sys/param.h	(working copy)
@@ -344,4 +344,45 @@
  */
 #define __PAST_END(array, offset) (((__typeof__(*(array)) *)(array))[offset])
 
+#ifdef _KERNEL
+
+/*
+ * We put here the definition of two debugging macros/function which
+ * are very convenient to have available.
+ * TSTMP(a,b,c,d,e,f) can be used to timestamp kernel events with the TSC,
+ * and export them to userland through a sysctl tree debug.timestamp,
+ * which holds one circular buffer per cpu. Events are 32 bytes each,
+ * formatted as TSC; LINE; a; b; c; d; e; f (all 32-bit arguments).
+ * They can be retrieved with something like
+
+	sysctl -b kern.ts.data | \
+	hexdump -e '"%15u %15u 0x%08x 0x%08x 0x%08x 0x%08x0x%08x 0x%08x\n"'
+
+ * The following sysctl variables are used
+ *	kern.ts.idx	opaque array of MAXCPU indexes
+ *	kern.ts.data	opaque array of all records
+ *	kern.ts.I.idx	integer - the next index for cpu I
+ *	kern.ts.I.data	opaque array of records for cpu I
+ *
+ * The buffer is preallocated (1M entries or so) and statically divided
+ * in blocks, one for each CPUs ( sysctl kern.smp.cpus ).
+ * The dump will report first entries for CPU0, then 1 and so on.
+ * The actual TSTMP code is in kern/subr_smp.c
+ *
+ * The macros must be enabled with "options KERN_TIMESTAMP" in the kernel
+ * config file, otherwise they default to an empty block.
+ */
+
+#define KERN_TIMESTAMP
+#ifdef KERN_TIMESTAMP
+extern void _TSTMP(uint32_t p[8]);
+#define TSTMP(a, b, c, d, e, f) do {				\
+	uint32_t p[8] = { __LINE__, rdtsc(), a, b, c, d, e, f};	\
+	_TSTMP(p);	} while (0)
+
+#else /* !KERN_TIMESTAMP */
+#define        TSTMP(a, b, c, d, e, f) do {} while (0)
+#endif /* !KERN_TIMESTAMP */
+#endif /* _KERNEL */
+
 #endif	/* _SYS_PARAM_H_ */
