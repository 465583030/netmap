Index: sys/dev/e1000/if_em.c
===================================================================
--- sys/dev/e1000/if_em.c	(revision 246924)
+++ sys/dev/e1000/if_em.c	(working copy)
@@ -32,6 +32,9 @@
 ******************************************************************************/
 /*$FreeBSD$*/
 
+#define MITIGATION
+#define PARAVIRT	/* enable virtio-like synchronization */
+
 #ifdef HAVE_KERNEL_OPTION_HEADERS
 #include "opt_device_polling.h"
 #include "opt_inet.h"
@@ -336,6 +339,9 @@
 
 static SYSCTL_NODE(_hw, OID_AUTO, em, CTLFLAG_RD, 0, "EM driver parameters");
 
+#define MAX_INTS_PER_SEC	8000
+#define DEFAULT_ITR		1000000000/(MAX_INTS_PER_SEC * 256)
+
 static int em_tx_int_delay_dflt = EM_TICKS_TO_USECS(EM_TIDV);
 static int em_rx_int_delay_dflt = EM_TICKS_TO_USECS(EM_RDTR);
 TUNABLE_INT("hw.em.tx_int_delay", &em_tx_int_delay_dflt);
@@ -356,8 +362,8 @@
     &em_rx_abs_int_delay_dflt, 0,
     "Default receive interrupt delay limit in usecs");
 
-static int em_rxd = EM_DEFAULT_RXD;
-static int em_txd = EM_DEFAULT_TXD;
+static int em_rxd = 8*EM_DEFAULT_RXD;
+static int em_txd = 8*EM_DEFAULT_TXD;
 TUNABLE_INT("hw.em.rxd", &em_rxd);
 TUNABLE_INT("hw.em.txd", &em_txd);
 SYSCTL_INT(_hw_em, OID_AUTO, rxd, CTLFLAG_RDTUN, &em_rxd, 0,
@@ -510,6 +516,47 @@
 		goto err_pci;
 	}
 
+#ifdef PARAVIRT
+	if (adapter->hw.subsystem_device_id == E1000_PARA_SUBDEV) {
+		uint64_t bus_addr;
+		int tsize;
+
+		device_printf(dev, "paravirt support on dev %p\n", adapter);
+		tsize = 4096; // XXX one page for the csb
+		if (em_dma_malloc(adapter, tsize, &adapter->csb_mem, BUS_DMA_NOWAIT)) {
+			device_printf(dev, "Unable to allocate csb memory\n");
+			error = ENOMEM;
+			goto err_pci;
+		}
+		/* Setup the Base of the CSB */
+		adapter->csb = (struct e1000_csb *)adapter->csb_mem.dma_vaddr;
+		/* force the first kick */
+		adapter->csb->host_need_txkick = 1; /* txring empty */
+		adapter->csb->guest_need_rxkick = 1; /* no rx packets */
+		bus_addr = adapter->csb_mem.dma_paddr;
+		em_set_sysctl_value(adapter, "csb_on",
+		    "enable paravirt.", &adapter->csb->guest_csb_on, 0);
+		em_set_sysctl_value(adapter, "txc_lim",
+		    "txc_lim", &adapter->csb->host_txcycles_lim, 1);
+		/* some stats */
+#define PA_SC(name, var, val)		\
+	em_set_sysctl_value(adapter, name, name, var, val)
+		PA_SC("host_need_txkick",&adapter->csb->host_need_txkick, 1);
+		PA_SC("host_need_rxkick",&adapter->csb->host_need_rxkick, 1);
+		PA_SC("guest_need_txkick",&adapter->csb->guest_need_txkick, 0);
+		PA_SC("guest_need_rxkick",&adapter->csb->guest_need_rxkick, 1);
+		PA_SC("tdt_reg_count",&adapter->tdt_reg_count, 0);
+		PA_SC("tdt_csb_count",&adapter->tdt_csb_count, 0);
+		PA_SC("tdt_int_count",&adapter->tdt_int_count, 0);
+		PA_SC("guest_need_kick_count",&adapter->guest_need_kick_count, 0);
+		/* tell the host where the block is */
+		E1000_WRITE_REG(&adapter->hw, E1000_CSBAH,
+			(u32)(bus_addr >> 32));
+		E1000_WRITE_REG(&adapter->hw, E1000_CSBAL,
+			(u32)bus_addr);
+	}
+#endif /* PARAVIRT */
+
 	/*
 	** For ICH8 and family we need to
 	** map the flash memory, and this
@@ -563,12 +610,25 @@
 	    &adapter->tx_abs_int_delay,
 	    E1000_REGISTER(hw, E1000_TADV),
 	    em_tx_abs_int_delay_dflt);
+	em_add_int_delay_sysctl(adapter, "itr",
+	    "interrupt delay limit in usecs/4",
+	    &adapter->tx_itr,
+	    E1000_REGISTER(&adapter->hw, E1000_ITR),
+	    DEFAULT_ITR);
 
 	/* Sysctl for limiting the amount of work done in the taskqueue */
 	em_set_sysctl_value(adapter, "rx_processing_limit",
 	    "max number of rx packets to process", &adapter->rx_process_limit,
 	    em_rx_process_limit);
 
+#ifdef MITIGATION
+	/* Sysctls to control mitigation */
+	em_set_sysctl_value(adapter, "mit_enable",
+	    "driver TDT mitigation", &adapter->mit_enable, 0);
+	em_set_sysctl_value(adapter, "rx_retries",
+	    "driver rx retries", &adapter->rx_retries, 0);
+#endif /* MITIGATION */
+
 	/*
 	 * Validate number of transmit and receive descriptors. It
 	 * must not exceed hardware maximum, and must be multiple
@@ -663,7 +723,7 @@
 			device_printf(dev,
 			    "The EEPROM Checksum Is Not Valid\n");
 			error = EIO;
-			goto err_late;
+			// XXX goto err_late;
 		}
 	}
 
@@ -741,6 +801,10 @@
 	if (adapter->ifp != NULL)
 		if_free(adapter->ifp);
 err_pci:
+#ifdef PARAVIRT
+	if (adapter->csb)
+		em_dma_free(adapter, &adapter->csb_mem);
+#endif /* PARAVIRT */
 	em_free_pci_resources(adapter);
 	free(adapter->mta, M_DEVBUF);
 	EM_CORE_LOCK_DESTROY(adapter);
@@ -788,6 +852,12 @@
 
 	e1000_phy_hw_reset(&adapter->hw);
 
+#ifdef PARAVIRT
+	if (adapter->csb) {
+		em_dma_free(adapter, &adapter->csb_mem);
+		adapter->csb = NULL;
+	}
+#endif /* PARAVIRT */
 	em_release_manageability(adapter);
 	em_release_hw_control(adapter);
 
@@ -942,6 +1012,16 @@
 		em_txeof(txr);
 	if (txr->tx_avail < EM_MAX_SCATTER)
 		ifp->if_drv_flags |= IFF_DRV_OACTIVE;
+#ifdef PARAVIRT
+	if (ifp->if_drv_flags & IFF_DRV_OACTIVE && adapter->csb &&
+	    adapter->csb->guest_csb_on && !adapter->csb->guest_need_txkick) {
+		adapter->csb->guest_need_txkick = 1;
+		adapter->guest_need_kick_count++;
+		// XXX memory barrier
+		em_txeof(txr); // XXX possibly clear IFF_DRV_OACTIVE
+	}
+#endif /* PARAVIRT */
+
 	return (err);
 }
 
@@ -2098,6 +2178,35 @@
 	 */
 	bus_dmamap_sync(txr->txdma.dma_tag, txr->txdma.dma_map,
 	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
+
+#ifdef PARAVIRT
+	if (adapter->csb) {
+		adapter->csb->guest_tdt = i;
+		/* XXX memory barrier ? */
+		if (adapter->csb->guest_csb_on &&
+		    !adapter->csb->host_need_txkick) {
+			if (txr->tx_avail <= 64) {// XXX
+				em_txeof(txr);
+			}
+			adapter->tdt_csb_count++;
+			return (0);
+		}
+	}
+#endif /* PARAVIRT */
+
+#ifdef MITIGATION
+	if (adapter->mit_enable) {
+		if (adapter->shadow_tdt & MIT_PENDING_INT) {
+			/* signal intr and data pending */
+			adapter->shadow_tdt = MIT_PENDING_TDT | (i & 0xffff);
+			return (0);
+		} else {
+			adapter->shadow_tdt = MIT_PENDING_INT;
+		}
+	}
+	adapter->tdt_reg_count++;
+#endif /* MITIGATION */
+
 	E1000_WRITE_REG(&adapter->hw, E1000_TDT(txr->me), i);
 
 	return (0);
@@ -2255,6 +2364,17 @@
 			taskqueue_enqueue(txr->tq, &txr->tx_task);
 	}
 	
+#if 0 // def PARAVIRT
+	/* recover space if needed */
+	if (adapter->csb && adapter->csb->guest_csb_on &&
+	    (adapter->watchdog_check == TRUE) &&
+	    (ticks - adapter->watchdog_time > EM_WATCHDOG) &&
+	    (txr->tx_avail != adapter->num_tx_desc) ) {
+		em_txeof(txr);
+		/* XXX should also recover from stalls ? */
+	}
+#endif /* PARAVIRT */
+
 	adapter->pause_frames = 0;
 	callout_reset(&adapter->timer, hz, em_local_timer, adapter);
 #ifndef DEVICE_POLLING
@@ -3877,6 +3997,17 @@
 
         txr->next_to_clean = first;
 
+#ifdef MITIGATION
+	if ((adapter->shadow_tdt & MIT_PENDING_TDT) == MIT_PENDING_TDT) {
+		/* a tdt write is pending, do it */
+		E1000_WRITE_REG(&adapter->hw, E1000_TDT(txr->me),
+		    0xffff & adapter->shadow_tdt);
+		adapter->shadow_tdt = MIT_PENDING_INT;
+	} else {
+		adapter->shadow_tdt = 0; // disable
+	}
+#endif /* MITIGATION */
+
 	/*
 	** Watchdog calculation, we know there's
 	** work outstanding or the first return
@@ -3975,6 +4106,14 @@
 	** Update the tail pointer only if,
 	** and as far as we have refreshed.
 	*/
+#ifdef PARAVIRT // XXX fix for multiqueue
+	if (cleaned) {
+		adapter->csb->guest_rdt = rxr->next_to_refresh;
+		if (adapter->csb->guest_csb_on &&
+		    !adapter->csb->host_need_rxkick)
+			return;
+	}
+#endif /* PARAVIRT */
 	if (cleaned)
 		E1000_WRITE_REG(&adapter->hw,
 		    E1000_RDT(rxr->me), rxr->next_to_refresh);
@@ -4246,8 +4385,6 @@
  *  Enable receive unit.
  *
  **********************************************************************/
-#define MAX_INTS_PER_SEC	8000
-#define DEFAULT_ITR	     1000000000/(MAX_INTS_PER_SEC * 256)
 
 static void
 em_initialize_receive_unit(struct adapter *adapter)
@@ -4306,6 +4443,7 @@
 		E1000_WRITE_REG(hw, E1000_RDTR, 0x20);
 
 	for (int i = 0; i < adapter->num_queues; i++, rxr++) {
+		int t = adapter->num_rx_desc - 1;
 		/* Setup the Base and Length of the Rx Descriptor Ring */
 		bus_addr = rxr->rxdma.dma_paddr;
 		E1000_WRITE_REG(hw, E1000_RDLEN(i),
@@ -4324,12 +4462,14 @@
 		if (ifp->if_capenable & IFCAP_NETMAP) {
 			struct netmap_adapter *na = NA(adapter->ifp);
 			struct netmap_kring *kring = &na->rx_rings[i];
-			int t = na->num_rx_desc - 1 - kring->nr_hwavail;
+			t = na->num_rx_desc - 1 - kring->nr_hwavail;
+		}
+#endif /* DEV_NETMAP */
 
-			E1000_WRITE_REG(hw, E1000_RDT(i), t);
-		} else
-#endif /* DEV_NETMAP */
-		E1000_WRITE_REG(hw, E1000_RDT(i), adapter->num_rx_desc - 1);
+#ifdef PARAVIRT
+		adapter->csb->guest_rdt = t;
+#endif /* PARAVIRT */
+		E1000_WRITE_REG(hw, E1000_RDT(i), t);
 	}
 
 	/* Set PTHRESH for improved jumbo performance */
@@ -4402,7 +4542,11 @@
 	int			i, processed, rxdone = 0;
 	bool			eop;
 	struct e1000_rx_desc	*cur;
+	int retries;
 
+#ifdef PARAVIRT
+	adapter->csb->guest_need_rxkick = 0;
+#endif /* PARAVIRT */
 	EM_RX_LOCK(rxr);
 
 #ifdef DEV_NETMAP
@@ -4419,6 +4563,7 @@
 	}
 #endif /* DEV_NETMAP */
 
+	retries = 0;
 	for (i = rxr->next_to_check, processed = 0; count != 0;) {
 
 		if ((ifp->if_drv_flags & IFF_DRV_RUNNING) == 0)
@@ -4431,8 +4576,21 @@
 		status = cur->status;
 		mp = sendmp = NULL;
 
-		if ((status & E1000_RXD_STAT_DD) == 0)
+		if ((status & E1000_RXD_STAT_DD) == 0) {
+			if (++retries <= adapter->rx_retries) {
+				continue;
+			}
+#ifdef PARAVIRT
+			if (adapter->csb->guest_need_rxkick == 0) {
+				adapter->csb->guest_need_rxkick = 1;
+				continue;
+			}
+#endif /* PARAVIRT */
 			break;
+		}
+#ifdef PARAVIRT
+		adapter->csb->guest_need_rxkick = 0;
+#endif /* PARAVIRT */
 
 		len = le16toh(cur->length);
 		eop = (status & E1000_RXD_STAT_EOP) != 0;
@@ -5614,6 +5772,8 @@
 		return (EINVAL);
 	info->value = usecs;
 	ticks = EM_USECS_TO_TICKS(usecs);
+	if (info->offset == E1000_ITR)  /* units are 256ns here */
+		ticks *= 4;
 
 	adapter = info->adapter;
 	
Index: sys/dev/e1000/if_em.h
===================================================================
--- sys/dev/e1000/if_em.h	(revision 246924)
+++ sys/dev/e1000/if_em.h	(working copy)
@@ -271,6 +271,28 @@
 	int value;			/* Current value in usecs */
 };
 
+#ifdef PARAVIRT
+#define	E1000_PARA_SUBDEV	0x1101		/* special id */
+#define	E1000_CSBAL		0x02830		/* csb physical address */
+#define	E1000_CSBAH		0x02834
+struct e1000_csb {				/* comm. block */
+	uint32_t	guest_tdt;		/* signals from guest */
+	uint32_t	guest_need_txkick;	/* out of tx bufs */
+	uint32_t	guest_need_rxkick;	/* out of rx bufs */
+	uint32_t	guest_csb_on;		/* mode enabled on the guest */
+	uint32_t	guest_rdt;		/* signals from guest */
+	uint32_t	pad[11];		/* to 64 bytes */
+
+	uint32_t	host_tdh;		/* mirror tdh, unused */
+	uint32_t	host_need_txkick;	/* enable mode */
+	uint32_t	host_txcycles_lim;	/* cycles before stop bh */
+	uint32_t	host_txcycles;		/* current bh cycles */
+	uint32_t	host_rdh;		/* mirror rdh, unused */
+	uint32_t	host_need_rxkick;	/* ??? */
+
+};
+#endif /* PARAVIRT */
+
 /*
  * The transmit ring, one per tx queue
  */
@@ -429,6 +451,7 @@
 	struct em_int_delay_info tx_abs_int_delay;
 	struct em_int_delay_info rx_int_delay;
 	struct em_int_delay_info rx_abs_int_delay;
+	struct em_int_delay_info tx_itr;
 
 	/* Misc stats maintained by the driver */
 	unsigned long	dropped_pkts;
@@ -440,6 +463,24 @@
 	unsigned long	watchdog_events;
 	unsigned long	link_irq;
 
+#ifdef MITIGATION
+	/* 0 = idle; 1xxxx int-pending; 3xxxx int + d pending + tdt */
+#define MIT_PENDING_INT	0x10000	/* pending interrupt */
+#define MIT_PENDING_TDT	0x30000	/* both intr and tdt write are pending */
+	uint32_t shadow_tdt;
+	uint32_t mit_enable;
+	uint32_t rx_retries;	/* optimize rx loop */
+#endif /* MITIGATION */
+
+#ifdef PARAVIRT
+	struct em_dma_alloc	csb_mem;	/* phys address */
+	struct e1000_csb	*csb;		/* virtual addr */
+	uint32_t		tdt_csb_count;// XXX stat
+	uint32_t		tdt_reg_count;// XXX stat
+	uint32_t		tdt_int_count;// XXX stat
+	uint32_t		guest_need_kick_count;// XXX stat
+#endif /* PARAVIRT */
+
 	struct e1000_hw_stats stats;
 };
 
Index: sys/dev/e1000/if_lem.c
===================================================================
--- sys/dev/e1000/if_lem.c	(revision 246924)
+++ sys/dev/e1000/if_lem.c	(working copy)
@@ -32,6 +32,9 @@
 ******************************************************************************/
 /*$FreeBSD$*/
 
+#define MITIGATION
+#define PARAVIRT	/* enable virtio-like synchronization */
+
 #ifdef HAVE_KERNEL_OPTION_HEADERS
 #include "opt_device_polling.h"
 #include "opt_inet.h"
@@ -281,12 +284,15 @@
 #define EM_TICKS_TO_USECS(ticks)	((1024 * (ticks) + 500) / 1000)
 #define EM_USECS_TO_TICKS(usecs)	((1000 * (usecs) + 512) / 1024)
 
+#define MAX_INTS_PER_SEC	8000
+#define DEFAULT_ITR	     1000000000/(MAX_INTS_PER_SEC * 256)
+
 static int lem_tx_int_delay_dflt = EM_TICKS_TO_USECS(EM_TIDV);
 static int lem_rx_int_delay_dflt = EM_TICKS_TO_USECS(EM_RDTR);
 static int lem_tx_abs_int_delay_dflt = EM_TICKS_TO_USECS(EM_TADV);
 static int lem_rx_abs_int_delay_dflt = EM_TICKS_TO_USECS(EM_RADV);
-static int lem_rxd = EM_DEFAULT_RXD;
-static int lem_txd = EM_DEFAULT_TXD;
+static int lem_rxd = 8*EM_DEFAULT_RXD;
+static int lem_txd = 8*EM_DEFAULT_TXD;
 static int lem_smart_pwr_down = FALSE;
 
 /* Controls whether promiscuous also shows bad packets */
@@ -442,6 +448,11 @@
 		    &adapter->tx_abs_int_delay,
 		    E1000_REGISTER(&adapter->hw, E1000_TADV),
 		    lem_tx_abs_int_delay_dflt);
+		lem_add_int_delay_sysctl(adapter, "itr",
+		    "interrupt delay limit in usecs/4",
+		    &adapter->tx_itr,
+		    E1000_REGISTER(&adapter->hw, E1000_ITR),
+		    DEFAULT_ITR);
 	}
 
 	/* Sysctls for limiting the amount of work done in the taskqueue */
@@ -449,6 +460,14 @@
 	    "max number of rx packets to process", &adapter->rx_process_limit,
 	    lem_rx_process_limit);
 
+#ifdef MITIGATION
+	/* Sysctls to control mitigation */
+	lem_add_rx_process_limit(adapter, "mit_enable",
+	    "driver TDT mitigation", &adapter->mit_enable, 0);
+	lem_add_rx_process_limit(adapter, "rx_retries",
+	    "driver rx retries", &adapter->rx_retries, 0);
+#endif /* MITIGATION */
+
         /* Sysctl for setting the interface flow control */
 	lem_set_flow_cntrl(adapter, "flow_control",
 	    "flow control setting",
@@ -506,6 +525,46 @@
 	 */
 	adapter->hw.mac.report_tx_early = 1;
 
+#ifdef PARAVIRT
+	if (adapter->hw.subsystem_device_id == E1000_PARA_SUBDEV) {
+		uint64_t bus_addr;
+
+		device_printf(dev, "paravirt support on dev %p\n", adapter);
+		tsize = 4096; // XXX one page for the csb
+		if (lem_dma_malloc(adapter, tsize, &adapter->csb_mem, BUS_DMA_NOWAIT)) {
+			device_printf(dev, "Unable to allocate csb memory\n");
+			error = ENOMEM;
+			goto err_csb;
+		}
+		/* Setup the Base of the CSB */
+		adapter->csb = (struct e1000_csb *)adapter->csb_mem.dma_vaddr;
+		/* force the first kick */
+		adapter->csb->host_need_txkick = 1; /* txring empty */
+		adapter->csb->guest_need_rxkick = 1; /* no rx packets */
+		bus_addr = adapter->csb_mem.dma_paddr;
+		lem_add_rx_process_limit(adapter, "csb_on",
+		    "enable paravirt.", &adapter->csb->guest_csb_on, 0);
+		lem_add_rx_process_limit(adapter, "txc_lim",
+		    "txc_lim", &adapter->csb->host_txcycles_lim, 1);
+		/* some stats */
+#define PA_SC(name, var, val)		\
+	lem_add_rx_process_limit(adapter, name, name, var, val)
+		PA_SC("host_need_txkick",&adapter->csb->host_need_txkick, 1);
+		PA_SC("host_need_rxkick",&adapter->csb->host_need_rxkick, 1);
+		PA_SC("guest_need_txkick",&adapter->csb->guest_need_txkick, 0);
+		PA_SC("guest_need_rxkick",&adapter->csb->guest_need_rxkick, 1);
+		PA_SC("tdt_reg_count",&adapter->tdt_reg_count, 0);
+		PA_SC("tdt_csb_count",&adapter->tdt_csb_count, 0);
+		PA_SC("tdt_int_count",&adapter->tdt_int_count, 0);
+		PA_SC("guest_need_kick_count",&adapter->guest_need_kick_count, 0);
+		/* tell the host where the block is */
+		E1000_WRITE_REG(&adapter->hw, E1000_CSBAH,
+			(u32)(bus_addr >> 32));
+		E1000_WRITE_REG(&adapter->hw, E1000_CSBAL,
+			(u32)bus_addr);
+	}
+#endif /* PARAVIRT */
+
 	tsize = roundup2(adapter->num_tx_desc * sizeof(struct e1000_tx_desc),
 	    EM_DBA_ALIGN);
 
@@ -664,6 +723,11 @@
 err_rx_desc:
 	lem_dma_free(adapter, &adapter->txdma);
 err_tx_desc:
+#ifdef PARAVIRT
+	lem_dma_free(adapter, &adapter->csb_mem);
+err_csb:
+#endif /* PARAVIRT */
+
 err_pci:
 	if (adapter->ifp != NULL)
 		if_free(adapter->ifp);
@@ -751,6 +815,12 @@
 		adapter->rx_desc_base = NULL;
 	}
 
+#ifdef PARAVIRT
+	if (adapter->csb) {
+		lem_dma_free(adapter, &adapter->csb_mem);
+		adapter->csb = NULL;
+	}
+#endif /* PARAVIRT */
 	lem_release_hw_control(adapter);
 	free(adapter->mta, M_DEVBUF);
 	EM_TX_LOCK_DESTROY(adapter);
@@ -860,6 +930,15 @@
 	}
 	if (adapter->num_tx_desc_avail <= EM_TX_OP_THRESHOLD)
 		ifp->if_drv_flags |= IFF_DRV_OACTIVE;
+#ifdef PARAVIRT
+	if (ifp->if_drv_flags & IFF_DRV_OACTIVE && adapter->csb &&
+	    adapter->csb->guest_csb_on && !adapter->csb->guest_need_txkick) {
+		adapter->csb->guest_need_txkick = 1;
+		adapter->guest_need_kick_count++;
+		// XXX memory barrier
+		lem_txeof(adapter); // XXX possibly clear IFF_DRV_OACTIVE
+	}
+#endif /* PARAVIRT */
 
 	return;
 }
@@ -1300,6 +1379,7 @@
 	lem_rxeof(adapter, -1, NULL);
 
 	EM_TX_LOCK(adapter);
+	adapter->tdt_int_count++;
 	lem_txeof(adapter);
 	if (ifp->if_drv_flags & IFF_DRV_RUNNING &&
 	    !IFQ_DRV_IS_EMPTY(&ifp->if_snd))
@@ -1337,12 +1417,17 @@
 
 
 	if (ifp->if_drv_flags & IFF_DRV_RUNNING) {
-		lem_rxeof(adapter, adapter->rx_process_limit, NULL);
+		bool more = lem_rxeof(adapter, adapter->rx_process_limit, NULL);
 		EM_TX_LOCK(adapter);
+		adapter->tdt_int_count++;
 		lem_txeof(adapter);
 		if (!IFQ_DRV_IS_EMPTY(&ifp->if_snd))
 			lem_start_locked(ifp);
 		EM_TX_UNLOCK(adapter);
+		if (more) {
+			taskqueue_enqueue(adapter->tq, &adapter->rxtx_task);
+			return;
+		}
 	}
 
 	if (ifp->if_drv_flags & IFF_DRV_RUNNING)
@@ -1702,6 +1787,35 @@
 	 */
 	bus_dmamap_sync(adapter->txdma.dma_tag, adapter->txdma.dma_map,
 	    BUS_DMASYNC_PREREAD | BUS_DMASYNC_PREWRITE);
+
+#ifdef PARAVIRT
+	if (adapter->csb) {
+		adapter->csb->guest_tdt = i;
+		/* XXX memory barrier ? */
+ 		if (adapter->csb->guest_csb_on &&
+		    !adapter->csb->host_need_txkick) {
+			if (adapter->num_tx_desc_avail <= 64) {// XXX
+				lem_txeof(adapter);
+			}
+			adapter->tdt_csb_count++;
+			return (0);
+		}
+	}
+#endif /* PARAVIRT */
+
+#ifdef MITIGATION
+	if (adapter->mit_enable) {
+		if (adapter->shadow_tdt & MIT_PENDING_INT) {
+			/* signal intr and data pending */
+			adapter->shadow_tdt = MIT_PENDING_TDT | (i & 0xffff);
+			return (0);
+		} else {
+			adapter->shadow_tdt = MIT_PENDING_INT;
+		}
+	}
+	adapter->tdt_reg_count++;
+#endif /* MITIGATION */
+
 	if (adapter->hw.mac.type == e1000_82547 &&
 	    adapter->link_duplex == HALF_DUPLEX)
 		lem_82547_move_tail(adapter);
@@ -1957,6 +2071,16 @@
 
 	lem_smartspeed(adapter);
 
+#ifdef PARAVIRT
+	/* recover space if needed */
+	if (adapter->csb && adapter->csb->guest_csb_on &&
+	    (adapter->watchdog_check == TRUE) &&
+	    (ticks - adapter->watchdog_time > EM_WATCHDOG) &&
+	    (adapter->num_tx_desc_avail != adapter->num_tx_desc) ) {
+		lem_txeof(adapter);
+		/* XXX should also recover from stalls ? */
+	}
+#endif /* PARAVIRT */
 	/*
 	 * We check the watchdog: the time since
 	 * the last TX descriptor was cleaned.
@@ -3027,6 +3151,16 @@
         adapter->next_tx_to_clean = first;
         adapter->num_tx_desc_avail = num_avail;
 
+#ifdef MITIGATION
+	if ((adapter->shadow_tdt & MIT_PENDING_TDT) == MIT_PENDING_TDT) {
+		/* a tdt write is pending, do it */
+		E1000_WRITE_REG(&adapter->hw, E1000_TDT(0),
+			0xffff & adapter->shadow_tdt);
+		adapter->shadow_tdt = MIT_PENDING_INT;
+	} else {
+		adapter->shadow_tdt = 0; // disable
+	}
+#endif /* MITIGATION */
         /*
          * If we have enough room, clear IFF_DRV_OACTIVE to
          * tell the stack that it is OK to send packets.
@@ -3034,6 +3168,12 @@
          */
         if (adapter->num_tx_desc_avail > EM_TX_CLEANUP_THRESHOLD) {                
                 ifp->if_drv_flags &= ~IFF_DRV_OACTIVE;
+#ifdef PARAVIRT
+		if (adapter->csb) {
+			adapter->csb->guest_need_txkick = 0;
+			// XXX memory barrier
+		}
+#endif /* PARAVIRT */
                 if (adapter->num_tx_desc_avail == adapter->num_tx_desc) {
 			adapter->watchdog_check = FALSE;
 			return;
@@ -3246,8 +3386,6 @@
  *  Enable receive unit.
  *
  **********************************************************************/
-#define MAX_INTS_PER_SEC	8000
-#define DEFAULT_ITR	     1000000000/(MAX_INTS_PER_SEC * 256)
 
 static void
 lem_initialize_receive_unit(struct adapter *adapter)
@@ -3347,9 +3485,16 @@
 
 		if (t >= na->num_rx_desc)
 			t -= na->num_rx_desc;
+#ifdef PARAVIRT
+		adapter->csb->guest_rdt = t;
+#endif /* PARAVIRT */
 		E1000_WRITE_REG(&adapter->hw, E1000_RDT(0), t);
-	} else
+		return;
+	}
 #endif /* DEV_NETMAP */
+#ifdef PARAVIRT
+	adapter->csb->guest_rdt = adapter->num_rx_desc - 1;
+#endif /* PARAVIRT */
 	E1000_WRITE_REG(&adapter->hw, E1000_RDT(0), adapter->num_rx_desc - 1);
 
 	return;
@@ -3426,7 +3571,12 @@
 	u16 		len, desc_len, prev_len_adj;
 	int		i, rx_sent = 0;
 	struct e1000_rx_desc   *current_desc;
+	int retries;
 
+#ifdef PARAVIRT
+	ND("clear guest_rxkick at %d", adapter->next_rx_desc_to_check);
+	adapter->csb->guest_need_rxkick = 0;
+#endif /* PARAVIRT */
 	EM_RX_LOCK(adapter);
 	i = adapter->next_rx_desc_to_check;
 	current_desc = &adapter->rx_desc_base[i];
@@ -3443,19 +3593,39 @@
 	}
 #endif /* DEV_NETMAP */
 
+#if 0 // XXX optimization ?
 	if (!((current_desc->status) & E1000_RXD_STAT_DD)) {
 		if (done != NULL)
 			*done = rx_sent;
 		EM_RX_UNLOCK(adapter);
 		return (FALSE);
 	}
+#endif /* 0 */
 
+	retries = 0;
 	while (count != 0 && ifp->if_drv_flags & IFF_DRV_RUNNING) {
 		struct mbuf *m = NULL;
 
 		status = current_desc->status;
-		if ((status & E1000_RXD_STAT_DD) == 0)
+		if ((status & E1000_RXD_STAT_DD) == 0) {
+			if (++retries <= adapter->rx_retries) {
+				continue;
+			}
+#ifdef PARAVIRT
+			if (adapter->csb->guest_need_rxkick == 0) {
+				ND("set guest_rxkick at %d", adapter->next_rx_desc_to_check);
+				adapter->csb->guest_need_rxkick = 1;
+				continue;
+			}
+#endif /* PARAVIRT */
 			break;
+		}
+#ifdef PARAVIRT
+		if (adapter->csb->guest_need_rxkick)
+			ND("clear again guest_rxkick at %d", adapter->next_rx_desc_to_check);
+		adapter->csb->guest_need_rxkick = 0;
+#endif /* PARAVIRT */
+		retries = 0;
 
 		mp = adapter->rx_buffer_area[i].m_head;
 		/*
@@ -3599,6 +3769,10 @@
 	/* Advance the E1000's Receive Queue #0  "Tail Pointer". */
 	if (--i < 0)
 		i = adapter->num_rx_desc - 1;
+#ifdef PARAVIRT
+	adapter->csb->guest_rdt = i;
+	if (!adapter->csb->guest_csb_on || adapter->csb->host_need_rxkick)
+#endif /* PARAVIRT */
 	E1000_WRITE_REG(&adapter->hw, E1000_RDT(0), i);
 	if (done != NULL)
 		*done = rx_sent;
@@ -4588,6 +4762,8 @@
 		return (EINVAL);
 	info->value = usecs;
 	ticks = EM_USECS_TO_TICKS(usecs);
+	if (info->offset == E1000_ITR)	/* units are 256ns here */
+		ticks *= 4;
 
 	adapter = info->adapter;
 	
Index: sys/dev/e1000/if_lem.h
===================================================================
--- sys/dev/e1000/if_lem.h	(revision 246924)
+++ sys/dev/e1000/if_lem.h	(working copy)
@@ -265,6 +265,28 @@
 #define PICOSECS_PER_TICK	20833
 #define TSYNC_PORT		319 /* UDP port for the protocol */
 
+#ifdef PARAVIRT
+#define	E1000_PARA_SUBDEV	0x1101		/* special id */
+#define	E1000_CSBAL		0x02830		/* csb physical address */
+#define	E1000_CSBAH		0x02834
+struct e1000_csb {				/* comm. block */
+	uint32_t	guest_tdt;		/* signals from guest */
+	uint32_t	guest_need_txkick;	/* out of tx bufs */
+	uint32_t	guest_need_rxkick;	/* out of rx bufs */
+	uint32_t	guest_csb_on;		/* mode enabled on the guest */
+	uint32_t	guest_rdt;		/* signals from guest */
+	uint32_t	pad[11];		/* to 64 bytes */
+
+	uint32_t	host_tdh;		/* mirror tdh, unused */
+	uint32_t	host_need_txkick;	/* enable mode */
+	uint32_t	host_txcycles_lim;	/* cycles before stop bh */
+	uint32_t	host_txcycles;		/* current bh cycles */
+	uint32_t	host_rdh;		/* mirror rdh, unused */
+	uint32_t	host_need_rxkick;	/* ??? */
+
+};
+#endif /* PARAVIRT */
+
 /*
  * Bus dma allocation structure used by
  * e1000_dma_malloc and e1000_dma_free.
@@ -363,6 +385,7 @@
 	struct em_int_delay_info tx_abs_int_delay;
 	struct em_int_delay_info rx_int_delay;
 	struct em_int_delay_info rx_abs_int_delay;
+	struct em_int_delay_info tx_itr;
 
 	/*
 	 * Transmit definitions
@@ -436,7 +459,24 @@
 	boolean_t       pcix_82544;
 	boolean_t       in_detach;
 
+#ifdef MITIGATION
+	/* 0 = idle; 1xxxx int-pending; 3xxxx int + d pending + tdt */
+#define MIT_PENDING_INT	0x10000	/* pending interrupt */
+#define MIT_PENDING_TDT	0x30000	/* both intr and tdt write are pending */
+	uint32_t shadow_tdt;
+	uint32_t mit_enable;
+	uint32_t rx_retries;	/* optimize rx loop */
+#endif /* MITIGATION */
 
+#ifdef PARAVIRT
+	struct em_dma_alloc	csb_mem;	/* phys address */
+	struct e1000_csb	*csb;		/* virtual addr */
+	uint32_t		tdt_csb_count;// XXX stat
+	uint32_t		tdt_reg_count;// XXX stat
+	uint32_t		tdt_int_count;// XXX stat
+	uint32_t		guest_need_kick_count;// XXX stat
+#endif /* PARAVIRT */
+
 	struct e1000_hw_stats stats;
 };
 
