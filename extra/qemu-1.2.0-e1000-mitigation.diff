diff -urp ../work-qemu-1.2.0-prod/hw/e1000.c ./hw/e1000.c
--- ../work-qemu-1.2.0-prod/hw/e1000.c	2012-09-05 07:03:06.000000000 -0700
+++ ./hw/e1000.c	2012-12-01 14:03:17.798698762 -0800
@@ -24,6 +24,7 @@
  * License along with this library; if not, see <http://www.gnu.org/licenses/>.
  */
 
+#define MITIGATION
 
 #include "hw.h"
 #include "pci.h"
@@ -127,6 +128,11 @@ typedef struct E1000State_st {
     } eecd_state;
 
     QEMUTimer *autoneg_timer;
+#ifdef MITIGATION
+    QEMUTimer *mit_timer;	// handle for the timer
+    uint32_t mit_timer_on;	// mitigation timer active
+    uint32_t mit_cause;		// pending interrupt cause
+#endif /* MITIGATION */
 } E1000State;
 
 #define	defreg(x)	x = (E1000_##x>>2)
@@ -142,6 +148,9 @@ enum {
     defreg(TPR),	defreg(TPT),	defreg(TXDCTL),	defreg(WUFC),
     defreg(RA),		defreg(MTA),	defreg(CRCERRS),defreg(VFTA),
     defreg(VET),
+#ifdef MITIGATION
+    defreg(RDTR),	defreg(RADV),	defreg(TADV),	defreg(ITR),
+#endif /* MITIGATION */
 };
 
 static void
@@ -626,6 +635,66 @@ static uint64_t tx_desc_base(E1000State
     return (bah << 32) + bal;
 }
 
+#ifdef MITIGATION
+/* helper function, 0 means the value is not set */
+static inline void
+mit_update_delay(uint32_t *cur, uint32_t value)
+{
+    if (value && (*cur == 0 || value < *cur))
+	*cur = value;
+}
+
+/*
+ * If necessary, rearm the timer and post an interrupt.
+ * Called at the end of tx/rx routines (mit_timer_on == 0),
+ * and when the timer fires (mit_timer_on == 1).
+ * We provide a partial implementation of interrupt mitigation,
+ * emulating only RADV, TADV and ITR (lower 16 bits, 1024ns units for
+ * RADV and TADV, 256ns units for ITR). RDTR is only used to enable RADV;
+ * relative timers based on TIDV and RDTR are not implemented.
+ */
+static void
+mit_rearm_and_int(void *opaque)
+{
+    E1000State *s = opaque;
+    uint32_t mit_delay = 0;
+
+    /*
+     * Clear the flag. It is only set when the callback fires,
+     * and we need to clear it anyways.
+     */
+    s->mit_timer_on = 0;
+    if (s->mit_cause == 0) /* no events pending, we are done */
+	return;
+    /*
+     * Compute the next mitigation delay according to pending interrupts
+     * and the current values of RADV (provided RDTR!=0), TADV and ITR.
+     * Then rearm the timer.
+     */
+    if (s->mit_cause & (E1000_ICR_TXQE | E1000_ICR_TXDW))
+	mit_update_delay(&mit_delay, s->mac_reg[TADV] * 4);
+    if (s->mac_reg[RDTR] && (s->mit_cause & E1000_ICS_RXT0))
+	mit_update_delay(&mit_delay, s->mac_reg[RADV] * 4);
+    mit_update_delay(&mit_delay, s->mac_reg[ITR]);  
+
+    if (likely(mit_delay)) {
+	s->mit_timer_on = 1;
+	qemu_mod_timer(s->mit_timer,
+		qemu_get_clock_ns(vm_clock) + mit_delay * 256);
+    }
+    set_ics(s, 0, s->mit_cause);
+    s->mit_cause = 0;
+}
+
+static void
+mit_set_ics(E1000State *s, uint32_t cause)
+{
+    s->mit_cause |= cause;
+    if (!s->mit_timer_on)
+	mit_rearm_and_int(s);
+}
+#endif /* MITIGATION */
+
 static void
 start_xmit(E1000State *s)
 {
@@ -663,7 +732,11 @@ start_xmit(E1000State *s)
             break;
         }
     }
+#ifdef MITIGATION
+    mit_set_ics(s, cause);
+#else /* !MITIGATION */
     set_ics(s, 0, cause);
+#endif /* !MITIGATION */
 }
 
 static int
@@ -875,7 +948,11 @@ e1000_receive(NetClientState *nc, const
         s->rxbuf_min_shift)
         n |= E1000_ICS_RXDMT0;
 
+#ifdef MITIGATION
+    mit_set_ics(s, n);
+#else /* !MITIGATION */
     set_ics(s, 0, n);
+#endif /* !MITIGATION */
 
     return size;
 }
@@ -978,6 +1055,9 @@ static uint32_t (*macreg_readops[])(E100
     getreg(RDH),	getreg(RDT),	getreg(VET),	getreg(ICS),
     getreg(TDBAL),	getreg(TDBAH),	getreg(RDBAH),	getreg(RDBAL),
     getreg(TDLEN),	getreg(RDLEN),
+#ifdef MITIGATION
+    getreg(RDTR),	getreg(RADV),	getreg(TADV),	getreg(ITR),
+#endif /* MITIGATION */
 
     [TOTH] = mac_read_clr8,	[TORH] = mac_read_clr8,	[GPRC] = mac_read_clr4,
     [GPTC] = mac_read_clr4,	[TPR] = mac_read_clr4,	[TPT] = mac_read_clr4,
@@ -994,6 +1074,10 @@ static void (*macreg_writeops[])(E1000St
     putreg(PBA),	putreg(EERD),	putreg(SWSM),	putreg(WUFC),
     putreg(TDBAL),	putreg(TDBAH),	putreg(TXDCTL),	putreg(RDBAH),
     putreg(RDBAL),	putreg(LEDCTL), putreg(VET),
+#ifdef MITIGATION
+    [RDTR] = set_16bit,	[RADV] = set_16bit,	[TADV] = set_16bit,
+    [ITR] = set_16bit,
+#endif /* MITIGATION */
     [TDLEN] = set_dlen,	[RDLEN] = set_dlen,	[TCTL] = set_tctl,
     [TDT] = set_tctl,	[MDIC] = set_mdic,	[ICS] = set_ics,
     [TDH] = set_16bit,	[RDH] = set_16bit,	[RDT] = set_rdt,
@@ -1253,6 +1337,11 @@ static int pci_e1000_init(PCIDevice *pci
     add_boot_device_path(d->conf.bootindex, &pci_dev->qdev, "/ethernet-phy@0");
 
     d->autoneg_timer = qemu_new_timer_ms(vm_clock, e1000_autoneg_timer, d);
+#ifdef MITIGATION
+    d->mit_cause = 0;
+    d->mit_timer_on = 0;
+    d->mit_timer = qemu_new_timer_ns(vm_clock, mit_rearm_and_int, d);
+#endif /* MITIGATION */
 
     return 0;
 }
