diff -urp work-qemu-1.2.0-prod/hw/e1000.c work-qemu-1.2.0-host/hw/e1000.c
--- work-qemu-1.2.0-prod/hw/e1000.c	2012-09-05 07:03:06.000000000 -0700
+++ work-qemu-1.2.0-host/hw/e1000.c	2012-11-30 13:53:59.056824388 -0800
@@ -24,6 +24,7 @@
  * License along with this library; if not, see <http://www.gnu.org/licenses/>.
  */
 
+#define MITIGATION
 
 #include "hw.h"
 #include "pci.h"
@@ -127,6 +128,11 @@ typedef struct E1000State_st {
     } eecd_state;
 
     QEMUTimer *autoneg_timer;
+#ifdef MITIGATION
+    QEMUTimer *mit_timer;	// handle for the timer
+    uint32_t mit_timer_on;	// mitigation timer active
+    uint32_t mit_cause;		// pending interrupt cause
+#endif /* MITIGATION */
 } E1000State;
 
 #define	defreg(x)	x = (E1000_##x>>2)
@@ -142,6 +148,9 @@ enum {
     defreg(TPR),	defreg(TPT),	defreg(TXDCTL),	defreg(WUFC),
     defreg(RA),		defreg(MTA),	defreg(CRCERRS),defreg(VFTA),
     defreg(VET),
+#ifdef MITIGATION
+    defreg(RDTR),	defreg(RADV),	defreg(TADV),	defreg(ITR),
+#endif /* MITIGATION */
 };
 
 static void
@@ -626,6 +635,62 @@ static uint64_t tx_desc_base(E1000State
     return (bah << 32) + bal;
 }
 
+#ifdef MITIGATION
+static inline void mit_update_delay(uint32_t *d, uint32_t value)
+{
+	if (value && (*d == 0 || value < *d))
+		*d = value;
+}
+
+/*
+ * if necessary, rearm the timer.
+ * Called at the end of tx/rx routines, and when the timer fires.
+ * We provide a partial implementation for the interrupt mitigation 
+ * mechanism, supporting RADV, TADV and ITR registers (only lower
+ * 16 bits, 1024ns units for RADV and TADV, 256ns units for ITR).
+ * RDTR is only used to enable RADV, and relative timers based on the
+ * TIDV and RDTR registers are not implemented.
+ */
+static void mit_rearm_timer(void *opaque)
+{
+    E1000State *s = opaque;
+
+    if (s->mit_cause == 0) {
+	/* If nothing is pending, do not rearm the timer. */
+	s->mit_timer_on = 0;
+    } else {
+	/*
+	 * Otherwise compute the next mitigation delay depending on 
+	 * the pending interrupts and on the current values of the
+	 * registers RADV (provided RDTR!=0), TADV and ITR.
+	 * Then rearm the timer.
+	 */
+	uint32_t mit_delay = 0;
+
+	if (s->mit_cause & (E1000_ICR_TXQE | E1000_ICR_TXDW))
+	    mit_update_delay(&mit_delay, s->mac_reg[TADV] * 4);
+	if (s->mac_reg[RDTR] && (s->mit_cause & E1000_ICS_RXT0))
+	    mit_update_delay(&mit_delay, s->mac_reg[RADV] * 4);
+	mit_update_delay(&mit_delay, s->mac_reg[ITR]);  
+	mit_delay *= 256;
+
+	if (likely(mit_delay)) {
+	    s->mit_timer_on = 1;
+	    qemu_mod_timer(s->mit_timer, qemu_get_clock_ns(vm_clock) + mit_delay);
+	}
+	set_ics(s, 0, s->mit_cause);
+	s->mit_cause = 0;
+    }
+}
+
+static void mit_set_ics(E1000State *s, uint32_t cause)
+{
+    s->mit_cause |= cause;
+    if (!s->mit_timer_on)
+	mit_rearm_timer(s);
+}
+#endif /* MITIGATION */
+
 static void
 start_xmit(E1000State *s)
 {
@@ -663,7 +728,11 @@ start_xmit(E1000State *s)
             break;
         }
     }
+#ifdef MITIGATION
+    mit_set_ics(s, cause);
+#else /* !MITIGATION */
     set_ics(s, 0, cause);
+#endif /* !MITIGATION */
 }
 
 static int
@@ -875,7 +944,11 @@ e1000_receive(NetClientState *nc, const
         s->rxbuf_min_shift)
         n |= E1000_ICS_RXDMT0;
 
+#ifdef MITIGATION
+    mit_set_ics(s, n);
+#else /* !MITIGATION */
     set_ics(s, 0, n);
+#endif /* !MITIGATION */
 
     return size;
 }
@@ -978,6 +1051,9 @@ static uint32_t (*macreg_readops[])(E100
     getreg(RDH),	getreg(RDT),	getreg(VET),	getreg(ICS),
     getreg(TDBAL),	getreg(TDBAH),	getreg(RDBAH),	getreg(RDBAL),
     getreg(TDLEN),	getreg(RDLEN),
+#ifdef MITIGATION
+    getreg(RDTR),	getreg(RADV),	getreg(TADV),	getreg(ITR),
+#endif /* MITIGATION */
 
     [TOTH] = mac_read_clr8,	[TORH] = mac_read_clr8,	[GPRC] = mac_read_clr4,
     [GPTC] = mac_read_clr4,	[TPR] = mac_read_clr4,	[TPT] = mac_read_clr4,
@@ -994,6 +1070,10 @@ static void (*macreg_writeops[])(E1000St
     putreg(PBA),	putreg(EERD),	putreg(SWSM),	putreg(WUFC),
     putreg(TDBAL),	putreg(TDBAH),	putreg(TXDCTL),	putreg(RDBAH),
     putreg(RDBAL),	putreg(LEDCTL), putreg(VET),
+#ifdef MITIGATION
+    [RDTR] = set_16bit,	[RADV] = set_16bit,	[TADV] = set_16bit,
+    [ITR] = set_16bit,
+#endif /* MITIGATION */
     [TDLEN] = set_dlen,	[RDLEN] = set_dlen,	[TCTL] = set_tctl,
     [TDT] = set_tctl,	[MDIC] = set_mdic,	[ICS] = set_ics,
     [TDH] = set_16bit,	[RDH] = set_16bit,	[RDT] = set_rdt,
@@ -1253,6 +1333,11 @@ static int pci_e1000_init(PCIDevice *pci
     add_boot_device_path(d->conf.bootindex, &pci_dev->qdev, "/ethernet-phy@0");
 
     d->autoneg_timer = qemu_new_timer_ms(vm_clock, e1000_autoneg_timer, d);
+#ifdef MITIGATION
+    d->mit_cause = 0;
+    d->mit_timer_on = 0;
+    d->mit_timer = qemu_new_timer_ns(vm_clock, mit_rearm_timer, d);
+#endif /* MITIGATION */
 
     return 0;
 }
