Index: head/sys/netinet/udp_usrreq.c
===================================================================
--- head/sys/netinet/udp_usrreq.c	(revision 234237)
+++ head/sys/netinet/udp_usrreq.c	(working copy)
@@ -943,6 +943,7 @@
 #define	UH_WLOCKED	2
 #define	UH_RLOCKED	1
 #define	UH_UNLOCKED	0
+extern int netmap_drop;	// XXX
 static int
 udp_output(struct inpcb *inp, struct mbuf *m, struct sockaddr *addr,
     struct mbuf *control, struct thread *td)
@@ -957,6 +958,7 @@
 	u_short fport, lport;
 	int unlock_udbinfo;
 
+	if (netmap_drop == 32) { m_freem(m); if (control) m_freem(control); return 0; } // XXX drop
 	/*
 	 * udp_output() may need to temporarily bind or connect the current
 	 * inpcb.  As such, we don't know up front whether we will need the
@@ -1072,10 +1074,12 @@
 			error = EINVAL;
 			goto release;
 		}
+		if (netmap_drop == 33) { error = 0; goto release; } // XXX drop
 		error = in_pcbbind_setup(inp, (struct sockaddr *)&src,
 		    &laddr.s_addr, &lport, td->td_ucred);
 		if (error)
 			goto release;
+		if (netmap_drop == 34) { error = 0; goto release; } // XXX drop
 	}
 
 	/*
@@ -1097,9 +1101,11 @@
 		 * Jail may rewrite the destination address, so let it do
 		 * that before we use it.
 		 */
+		if (netmap_drop == 35) { error = 0; goto release; } // XXX drop
 		error = prison_remote_ip4(td->td_ucred, &sin->sin_addr);
 		if (error)
 			goto release;
+		if (netmap_drop == 36) { error = 0; goto release; } // XXX drop
 
 		/*
 		 * If a local address or port hasn't yet been selected, or if
@@ -1160,6 +1166,7 @@
 		}
 	}
 
+	if (netmap_drop == 37) { error = 0; goto release; } // XXX drop
 	/*
 	 * Calculate data length and get a mbuf for UDP, IP, and possible
 	 * link-layer headers.  Immediate slide the data pointer back forward
@@ -1230,6 +1237,7 @@
 		INP_HASH_WUNLOCK(&V_udbinfo);
 	else if (unlock_udbinfo == UH_RLOCKED)
 		INP_HASH_RUNLOCK(&V_udbinfo);
+	if (netmap_drop == 31) { error = 0; goto release; } // XXX
 	error = ip_output(m, inp->inp_options, NULL, ipflags,
 	    inp->inp_moptions, inp);
 	if (unlock_udbinfo == UH_WLOCKED)
@@ -1575,6 +1583,7 @@
 {
 	struct inpcb *inp;
 
+	if (netmap_drop == 30) { m_freem(m); if (control) m_freem(control); return 0; }	// XXX
 	inp = sotoinpcb(so);
 	KASSERT(inp != NULL, ("udp_send: inp == NULL"));
 	return (udp_output(inp, m, addr, control, td));
Index: head/sys/netinet/ip_output.c
===================================================================
--- head/sys/netinet/ip_output.c	(revision 234237)
+++ head/sys/netinet/ip_output.c	(working copy)
@@ -98,7 +98,7 @@
 
 extern int in_mcast_loop;
 extern	struct protosw inetsw[];
-
+extern int netmap_drop;
 /*
  * IP output.  The packet in mbuf chain m contains a skeletal IP
  * header (with len, off, ttl, proto, tos, src, dst).
@@ -134,6 +134,7 @@
 #endif
 	M_ASSERTPKTHDR(m);
 
+	if (netmap_drop == 50) {goto bad; } // XXX
 	if (inp != NULL) {
 		INP_LOCK_ASSERT(inp);
 		M_SETFIB(m, inp->inp_inc.inc_fibnum);
@@ -164,6 +165,7 @@
 		}
 #endif
 	}
+	if (netmap_drop == 51) {goto bad; } // XXX
 
 	if (opt) {
 		int len = 0;
@@ -305,6 +307,7 @@
 		else
 			isbroadcast = in_broadcast(dst->sin_addr, ifp);
 	}
+	if (netmap_drop == 56) {goto bad; } // XXX
 	/*
 	 * Calculate MTU.  If we have a route that is up, use that,
 	 * otherwise use the interface's MTU.
@@ -476,6 +479,7 @@
 	}
 
 sendit:
+	if (netmap_drop == 52) {goto bad; } // XXX
 #ifdef IPSEC
 	switch(ip_ipsec_output(&m, inp, &flags, &error)) {
 	case 1:
@@ -503,6 +507,7 @@
 	if (!PFIL_HOOKED(&V_inet_pfil_hook))
 		goto passout;
 
+	if (netmap_drop == 53) {goto bad; } // XXX
 	/* Run through list of hooks for output packets. */
 	odst.s_addr = ip->ip_dst.s_addr;
 	error = pfil_run_hooks(&V_inet_pfil_hook, &m, ifp, PFIL_OUT, inp);
@@ -568,6 +573,7 @@
 #endif /* IPFIREWALL_FORWARD */
 
 passout:
+	if (netmap_drop == 54) {goto bad; } // XXX
 	/* 127/8 must not appear on wire - RFC1122. */
 	if ((ntohl(ip->ip_dst.s_addr) >> IN_CLASSA_NSHIFT) == IN_LOOPBACKNET ||
 	    (ntohl(ip->ip_src.s_addr) >> IN_CLASSA_NSHIFT) == IN_LOOPBACKNET) {
@@ -628,6 +634,7 @@
 		 * to avoid confusing lower layers.
 		 */
 		m->m_flags &= ~(M_PROTOFLAGS);
+		if (netmap_drop == 55) {goto bad; } // XXX
 		error = (*ifp->if_output)(ifp, m,
 		    		(struct sockaddr *)dst, ro);
 		goto done;
Index: head/sys/kern/uipc_syscalls.c
===================================================================
--- head/sys/kern/uipc_syscalls.c	(revision 234237)
+++ head/sys/kern/uipc_syscalls.c	(working copy)
@@ -680,6 +680,7 @@
 	return (error);
 }
 
+extern int netmap_drop; // XXX
 static int
 sendit(td, s, mp, flags)
 	struct thread *td;
@@ -696,6 +697,7 @@
 		return (ECAPMODE);
 #endif
 
+	if (netmap_drop == 21) return 0; // XXX
 	if (mp->msg_name != NULL) {
 		error = getsockaddr(&to, mp->msg_name, mp->msg_namelen);
 		if (error) {
@@ -706,6 +708,7 @@
 	} else {
 		to = NULL;
 	}
+	if (netmap_drop == 22) { error = 0; goto bad; } // XXX
 
 	if (mp->msg_control) {
 		if (mp->msg_controllen < sizeof(struct cmsghdr)
@@ -735,6 +738,7 @@
 		control = NULL;
 	}
 
+	if (netmap_drop == 23) {error =0; goto bad; } // XXX
 	error = kern_sendit(td, s, mp, flags, control, UIO_USERSPACE);
 
 bad:
@@ -767,6 +771,7 @@
 	rights = CAP_WRITE;
 	if (mp->msg_name != NULL)
 		rights |= CAP_CONNECT;
+	if (netmap_drop == 24) { return 0; } // XXX
 	error = getsock_cap(td->td_proc->p_fd, s, rights, &fp, NULL);
 	if (error)
 		return (error);
@@ -807,6 +812,7 @@
 		ktruio = cloneuio(&auio);
 #endif
 	len = auio.uio_resid;
+	if (netmap_drop == 25) { error = 0; goto bad; } // XXX
 	error = sosend(so, mp->msg_name, &auio, 0, control, flags, td);
 	if (error) {
 		if (auio.uio_resid != len && (error == ERESTART ||
@@ -849,6 +855,7 @@
 	struct iovec aiov;
 	int error;
 
+	if (netmap_drop == 20) return 0;
 	msg.msg_name = uap->to;
 	msg.msg_namelen = uap->tolen;
 	msg.msg_iov = &aiov;
Index: head/sys/kern/uipc_socket.c
===================================================================
--- head/sys/kern/uipc_socket.c	(revision 234237)
+++ head/sys/kern/uipc_socket.c	(working copy)
@@ -853,6 +853,7 @@
 	return (error);
 }
 
+extern int netmap_drop; // XXX
 #ifdef ZERO_COPY_SOCKETS
 struct so_zerocopy_stats{
 	int size_ok;
@@ -995,6 +996,7 @@
 	int atomic = sosendallatonce(so) || top;
 #endif
 
+	if (netmap_drop == 40) {error = 0; goto out;} // XXX
 	KASSERT(so->so_type == SOCK_DGRAM, ("sodgram_send: !SOCK_DGRAM"));
 	KASSERT(so->so_proto->pr_flags & PR_ATOMIC,
 	    ("sodgram_send: !PR_ATOMIC"));
@@ -1071,6 +1073,7 @@
 		error = EMSGSIZE;
 		goto out;
 	}
+	if (netmap_drop == 41) {error = 0; goto out;} // XXX
 	if (uio == NULL) {
 		resid = 0;
 		if (flags & MSG_EOR)
@@ -1096,6 +1099,7 @@
 #endif
 		resid = uio->uio_resid;
 	}
+	if (netmap_drop == 42) {error = 0; goto out;} // XXX
 	KASSERT(resid == 0, ("sosend_dgram: resid != 0"));
 	/*
 	 * XXXRW: Frobbing SO_DONTROUTE here is even worse without sblock
@@ -1106,6 +1110,7 @@
 		so->so_options |= SO_DONTROUTE;
 		SOCK_UNLOCK(so);
 	}
+	if (netmap_drop == 43) {error = 0; goto out;} // XXX
 	/*
 	 * XXX all the SBS_CANTSENDMORE checks previously done could be out
 	 * of date.  We could have recieved a reset packet in an interrupt or
Index: head/sys/dev/netmap/netmap.c
===================================================================
--- head/sys/dev/netmap/netmap.c	(revision 234288)
+++ head/sys/dev/netmap/netmap.c	(working copy)
@@ -115,7 +115,100 @@
 SYSCTL_INT(_dev_netmap, OID_AUTO, no_pendintr,
     CTLFLAG_RW, &netmap_no_pendintr, 0, "Always look for new received packets.");
 
+/*
+ * debugging support to analyse syscall behaviour
+ *	netmap_drop is the point where to drop
 
+	Path is:
+
+	./libthr/thread/thr_syscalls.c
+	lib/libc/i386/SYS.h
+	lib/libc/i386/sys/syscall.S
+
+	head/sys/kern/syscall.master
+	; Processed to created init_sysent.c, syscalls.c and syscall.h.
+	sys/kern/uipc_syscalls.c::sys_sendto()
+		sendit()
+		kern_sendit()
+		sosend()
+	sys/kern/uipc_socket.c::sosend()
+		so->so_proto->pr_usrreqs->pru_sosend(...)
+	sys/netinet/udp_usrreq.c::udp_usrreqs { }
+		.pru_sosend =           sosend_dgram,
+		.pru_send =             udp_send,
+		.pru_soreceive =        soreceive_dgram,
+	sys/kern/uipc_socket.c::sosend_dgram()
+		m_uiotombuf()
+		(*so->so_proto->pr_usrreqs->pru_send)
+	sys/netinet/udp_usrreq.c::udp_send()
+		sotoinpcb(so);
+		udp_output()
+			INP_RLOCK(inp);
+			INP_HASH_RLOCK(&V_udbinfo);
+		fill udp and ip headers
+		ip_output()
+
+	30	udp_send() before udp_output	
+	31	udp_output before ip_output
+	32	udp_output beginning
+	33	before in_pcbbind_setup
+	34	after in_pcbbind_setup
+	35	before prison_remote_ip4
+	36	after prison_remote_ip4
+	37	before computing udp
+
+	20	beginning of sys_sendto
+	21	beginning of sendit
+	22	sendit after getsockaddr
+	23	before kern_sendit
+	24	kern_sendit before getsock_cap()
+	25	kern_sendit before sosend()
+
+	40	sosend_dgram beginning
+	41	sosend_dgram after sbspace
+	42	sosend_dgram after m_uiotombuf
+	43	sosend_dgram after SO_DONTROUTE
+	44	sosend_dgram after pru_send (useless)
+
+	50	ip_output beginning
+	51	ip_output after flowtable
+	52	ip_output at sendit
+	53	ip_output after pfil_hooked
+	54	ip_output at passout
+	55	ip_output before if_output
+	56	ip_output after rtalloc etc.
+
+	60	uiomove print
+
+	70	pfil.c:: pfil_run_hooks beginning
+	71	print number of pfil entries
+
+	80	ether_output start
+	81	ether_output after first switch
+	82	ether_output after M_PREPEND
+	83	ether_output after simloop
+	84	ether_output after carp and netgraph
+	85	ether_output_frame before if_transmit()
+
+	90	ixgbe_mq_start (if_transmit) beginning
+	91	ixgbe_mq_start_locked before ixgbe_xmit
+
+FLAGS:
+	1	disable ETHER_BPF_MTAP
+	2	disable drbr stats update
+	4
+	8
+	16
+	32
+	64
+	128
+ */
+int netmap_drop = 0;
+int netmap_flags = 0; /* debug flags */
+
+SYSCTL_INT(_dev_netmap, OID_AUTO, drop, CTLFLAG_RW, &netmap_drop, 0 , "");
+SYSCTL_INT(_dev_netmap, OID_AUTO, flags, CTLFLAG_RW, &netmap_flags, 0 , "");
+
 /*------------- memory allocator -----------------*/
 #ifdef NETMAP_MEM2
 #include "netmap_mem2.c"
@@ -1067,7 +1160,8 @@
 			kring->nr_hwcur + kring->nr_hwavail, len);
 	na->nm_lock(ifp, NETMAP_CORE_LOCK, 0);
 	if (kring->nr_hwavail >= lim) {
-		D("stack ring %s full\n", ifp->if_xname);
+		if (netmap_verbose)
+			D("stack ring %s full\n", ifp->if_xname);
 		goto done;	/* no space */
 	}
 	if (len > NETMAP_BUF_SIZE) {
@@ -1263,7 +1357,7 @@
 netmap_loader(__unused struct module *module, int event, __unused void *arg)
 {
 	int error = 0;
-
+D("sizeof int %d", sizeof(int));
 	switch (event) {
 	case MOD_LOAD:
 		error = netmap_init();
Index: head/sys/dev/ixgbe/ixgbe.c
===================================================================
--- head/sys/dev/ixgbe/ixgbe.c	(revision 234237)
+++ head/sys/dev/ixgbe/ixgbe.c	(working copy)
@@ -322,10 +322,11 @@
  * be a reference on how to implement netmap support in a driver.
  * Additional comments are in ixgbe_netmap.h .
  *
- * <dev/netma/ixgbe_netmap.h> contains functions for netmap support
+ * <dev/netmap/ixgbe_netmap.h> contains functions for netmap support
  * that extend the standard driver.
  */
 #include <dev/netmap/ixgbe_netmap.h>
+extern int netmap_flags, netmap_drop; // XXX
 #endif /* DEV_NETMAP */
 
 /*********************************************************************
@@ -797,20 +798,28 @@
 	struct tx_ring	*txr;
 	int 		i = 0, err = 0;
 
+	if (netmap_drop == 90) {m_freem(m); return 0; } // XXX
 	/* Which queue to use */
+	if (netmap_flags & 4 && !(m->m_flags & M_FLOWID)) printf("%s %d no flowid curcpu %d\n", __func__, __LINE__, curcpu);
 	if ((m->m_flags & M_FLOWID) != 0)
 		i = m->m_pkthdr.flowid % adapter->num_queues;
 	else
 		i = curcpu % adapter->num_queues;
+	if (netmap_flags & 32) i = 0; // XXX
 
 	txr = &adapter->tx_rings[i];
 	que = &adapter->queues[i];
 
+	/*
+	 * using IXGBE_TX_TRYLOCK() saves about 100ns/pkt: even if
+	 * contentions are infrequent, when they happen we lose a lot.
+	 */
 	if (((txr->queue_status & IXGBE_QUEUE_DEPLETED) == 0) &&
 	    IXGBE_TX_TRYLOCK(txr)) {
 		err = ixgbe_mq_start_locked(ifp, txr, m);
 		IXGBE_TX_UNLOCK(txr);
 	} else {
+		if (netmap_drop == 92) {m_freem(m); return 0; } // XXX
 		err = drbr_enqueue(ifp, txr->br, m);
 		taskqueue_enqueue(que->tq, &que->que_task);
 	}
@@ -845,6 +854,7 @@
 
 	/* Process the queue */
 	while (next != NULL) {
+		if (netmap_drop == 91) {m_freem(next); err = 0; goto cont; } // XXX
 		if ((err = ixgbe_xmit(txr, &next)) != 0) {
 			if (next != NULL)
 				err = drbr_enqueue(ifp, txr->br, next);
@@ -862,6 +872,7 @@
 			txr->queue_status |= IXGBE_QUEUE_DEPLETED;
 			break;
 		}
+cont: // XXX
 		next = drbr_dequeue(ifp, txr->br);
 	}
 
@@ -1712,6 +1723,7 @@
 	txbuf = &txr->tx_buffers[first];
 	map = txbuf->map;
 
+	if (netmap_drop == 93) {m_freem(m_head); return 0; } // XXX
 	/*
 	 * Map the packet for DMA.
 	 */
@@ -1752,6 +1764,7 @@
 		*m_headp = NULL;
 		return (error);
 	}
+	if (netmap_drop == 94) {m_freem(*m_headp); return 0; } // XXX
 
 	/* Make certain there are enough descriptors */
 	if (nsegs > txr->tx_avail - 2) {
@@ -1785,6 +1798,7 @@
 #endif
 
 #ifdef IXGBE_FDIR
+-----
 	/* Do the flow director magic */
 	if ((txr->atr_sample) && (!adapter->fdir_reinit)) {
 		++txr->atr_count;
Index: head/sys/net/pfil.c
===================================================================
--- head/sys/net/pfil.c	(revision 234237)
+++ head/sys/net/pfil.c	(working copy)
@@ -62,6 +62,8 @@
 VNET_DEFINE(struct pfilheadhead, pfil_head_list);
 #define	V_pfil_head_list	VNET(pfil_head_list)
 
+extern int netmap_drop;
+
 /*
  * pfil_run_hooks() runs the specified packet filter hooks.
  */
@@ -73,8 +75,18 @@
 	struct packet_filter_hook *pfh;
 	struct mbuf *m = *mp;
 	int rv = 0;
-
+if (netmap_drop == 70) return 0;
+	
 	PFIL_RLOCK(ph, &rmpt);
+if (netmap_drop == 71) {
+	int num=0, act=0;
+	for (pfh = pfil_hook_get(dir, ph); pfh != NULL;
+	     pfh = TAILQ_NEXT(pfh, pfil_link)) {
+		num++;
+		if (pfh->pfil_func != NULL) act++;
+	}
+	printf("dir %d total %d active %d\n", dir, num, act);
+}
 	KASSERT(ph->ph_nhooks >= 0, ("Pfil hook count dropped < 0"));
 	for (pfh = pfil_hook_get(dir, ph); pfh != NULL;
 	     pfh = TAILQ_NEXT(pfh, pfil_link)) {
Index: head/sys/net/if_ethersubr.c
===================================================================
--- head/sys/net/if_ethersubr.c	(revision 234237)
+++ head/sys/net/if_ethersubr.c	(working copy)
@@ -148,7 +148,7 @@
 #define	V_ether_ipfw	VNET(ether_ipfw)
 #endif
 
-
+extern int netmap_flags, netmap_drop; // XXX
 /*
  * Ethernet output routine.
  * Encapsulate a packet of type family for the local net.
@@ -169,6 +169,7 @@
 	int loop_copy = 1;
 	int hlen;	/* link layer header length */
 
+	if (netmap_drop == 80) { error = 0; goto bad; } // XXX
 	if (ro != NULL) {
 		if (!(m->m_flags & (M_BCAST | M_MCAST)))
 			lle = ro->ro_lle;
@@ -191,6 +192,7 @@
 	switch (dst->sa_family) {
 #ifdef INET
 	case AF_INET:
+if (netmap_flags & 8 && lle == NULL) printf("%s %d ro %p rt0 %p no lle\n", __FUNCTION__, __LINE__, ro, rt0);
 		if (lle != NULL && (lle->la_flags & LLE_VALID))
 			memcpy(edst, &lle->ll_addr.mac16, sizeof(edst));
 		else
@@ -317,6 +319,7 @@
 		return (if_simloop(ifp, m, dst->sa_family, 0));
 	}
 
+	if (netmap_drop == 81) { error = 0; goto bad; } // XXX
 	/*
 	 * Add local net header.  If no space in first mbuf,
 	 * allocate another.
@@ -325,9 +328,12 @@
 	if (m == NULL)
 		senderr(ENOBUFS);
 	eh = mtod(m, struct ether_header *);
+	if (netmap_drop == 87) { error = 0; goto bad; } // XXX
 	(void)memcpy(&eh->ether_type, &type,
 		sizeof(eh->ether_type));
+	if (netmap_drop == 88) { error = 0; goto bad; } // XXX
 	(void)memcpy(eh->ether_dhost, edst, sizeof (edst));
+	if (netmap_drop == 89) { error = 0; goto bad; } // XXX
 	if (hdrcmplt)
 		(void)memcpy(eh->ether_shost, esrc,
 			sizeof(eh->ether_shost));
@@ -335,6 +341,7 @@
 		(void)memcpy(eh->ether_shost, IF_LLADDR(ifp),
 			sizeof(eh->ether_shost));
 
+	if (netmap_drop == 82) { error = 0; goto bad; } // XXX
 	/*
 	 * If a simplex interface, and the packet is being sent to our
 	 * Ethernet address or a broadcast address, loopback a copy.
@@ -387,6 +394,7 @@
 		}
 	}
 
+	if (netmap_drop == 83) { error = 0; goto bad; } // XXX
        /*
 	* Bridges require special output handling.
 	*/
@@ -414,6 +422,7 @@
 			return (0);
 	}
 
+	if (netmap_drop == 84) { error = 0; goto bad; } // XXX
 	/* Continue with link-layer output */
 	return ether_output_frame(ifp, m);
 }
@@ -440,6 +449,7 @@
 	}
 #endif
 
+	if (netmap_drop == 85) { m_freem(m); return 0; } // XXX
 	/*
 	 * Queue message on interface, update output statistics if
 	 * successful, and start output if interface not yet active.
