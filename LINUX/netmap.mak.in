# To build external modules, you must have a prebuilt kernel available
# that contains the configuration and header files used in the build.
# go in the kernel directory and do a
#       make oldconfig; make scripts; make prepare
# or    make defconfig; make scripts; make prepare
#

MODNAME:=@MODNAME@
SUBSYS:=@SUBSYS@
SRCDIR:=@SRCDIR@
BUILDDIR:=@BUILDDIR@

# The following commands are needed to build the modules as out-of-tree,
# in fact the kernel sources path must be specified.

# Additional compile flags (e.g. header location)
EXTRA_CFLAGS := -I$(BUILDDIR) -I$(SRCDIR) -I$(SRCDIR)/../sys -I$(SRCDIR)/../sys/dev -DCONFIG_NETMAP
EXTRA_CFLAGS += -Wno-unused-but-set-variable
EXTRA_CFLAGS += $(foreach s,$(SUBSYS),-DCONFIG_NETMAP_$(shell echo $s|tr a-z- A-Z_))


# We use KSRC for the kernel configuration and sources.
# If the sources are elsewhere, then use SRC to point to them.
KSRC = @KSRC@
SRC  = @SRC@
KOPTS = @KOPTS@
MODPATH = @MODPATH@
LIN_VER = @LIN_VER@
MOD_LIST := @MOD_LIST@
PATCHES = @PATCHES@
S_DRIVERS = @S_DRIVERS@
E_DRIVERS = @E_DRIVERS@
DRVSUFFIX = @DRVSUFFIX@

# actual drivers after copy and patch
DRIVERS = $(shell [ -n "$(S_DRIVERS)" ] && ls -dAp $(S_DRIVERS) 2> /dev/null)
# external drivers after copy and patch
DRIVERS_EXT = $(shell [ -n "$(E_DRIVERS)" ] && ls -dAp $(E_DRIVERS) 2> /dev/null)

COMMON_OPTS=-C $(KSRC) M=$(BUILDDIR) EXTRA_CFLAGS='$(EXTRA_CFLAGS)' $(KOPTS) modules

define get_driver
get-$(1):
	$($(1)@src)
	$(foreach p,$($(1)@patch),patch --posix --quiet --force -p1 < $(p);)
	$(if $($(1)@build),,$(if $(filter-out %.c,$(1)),mv $(1)/Makefile $(1)/orig.mak || mv $(1)/Kbuild $(1)/orig.mak; cp drv-subdir.mak $(1)/Makefile,))
	touch get-$(1)
clean-$(1):
	rm -rf $(if $($(1)@cleandir),$($(1)@cleandir),$($(1)@dst)) get-$(1)
endef

define build_driver
build-$(1): get-$(1) netmap.ko
	D=$(if $($(1)@dst),$($(1)@dst),$(1)); if [ -d "$$$$D" ] && [ -e Module.symvers ]; then cp Module.symvers "$$$$D"; fi
	$($(1)@build)
endef

.PHONY: $(foreach d,$(E_DRIVERS),build-$(d)) netmap.ko


all: $(S_DRIVERS:%=get-%) netmap.ko $(E_DRIVERS:%=build-%)

netmap.ko:
	$(MAKE) $(COMMON_OPTS) CONFIG_NETMAP=m $(MOD_LIST) O_DRIVERS="$(patsubst %.c,%.o,$(filter-out $(DRIVERS_EXT),$(DRIVERS)))" NETMAP_DRIVER_SUFFIX=$(DRVSUFFIX)

-include config.mak
include drivers.mak

$(foreach d,$(S_DRIVERS),$(eval $(call get_driver,$(d))))
$(foreach d,$(E_DRIVERS),$(eval $(call build_driver,$(d))))

install:
	$(MAKE) -C $(KSRC) M=$(BUILDDIR) CONFIG_NETMAP=m $(MOD_LIST) \
		O_DRIVERS="$(DRIVERS:%.c=%.o)" \
		$(KOPTS) \
		NETMAP_DRIVER_SUFFIX=$(DRVSUFFIX) \
		$(if $(MODPATH),INSTALL_MOD_PATH=$(MODPATH)) \
		modules_install

clean: $(S_DRIVERS:%=clean-%)
	-@ $(MAKE) -C $(KSRC) M=$(BUILDDIR) clean 2> /dev/null
	-@ $(MAKE) -C build-apps clean
	-@ rm -f *.orig *.rej *.ko *.o .*.d 		\
		*.mod.c modules.order			\
		Module.symvers .*.cmd
	-@ rm -rf .tmp_versions


APPS_CC=@APPS_CC@
APPS_LD=@APPS_LD@
PREFIX=@PREFIX@
DESTDIR?=@DESTDIR@

.PHONY: apps
apps:
	$(MAKE) -C build-apps SRCDIR=$(SRCDIR)/.. CC="$(APPS_CC)" LD="$(APPS_LD)"

install-apps:
	$(MAKE) -C build-apps install SRCDIR=$(SRCDIR)/.. DESTDIR="$(abspath $(DESTDIR))" PREFIX="$(PREFIX)"

+%:
	@echo $($*)

distclean: clean
	rm -f config.status config.log netmap_linux_config.h \
		patches drivers.mak Kbuild netmap.mak config.mak
	rm -rf netmap-tmpdir
	if [ -L GNUmakefile ]; then rm GNUmakefile; fi
	if [ -L drv-subdir.mak ]; then rm drv-subdir.mak; fi
	if [ -L read-vars.mak ]; then rm read-vars.mak; fi
	rm -rf build-apps
