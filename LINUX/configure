#!/bin/bash

TOPDIR=$PWD

prefix=/usr/local
cc=cc
ld=ld

# with <command>: success iff <command> is available
with() {
	type $1 >/dev/null 2>&1
}

print_realpath() {
	if with realpath; then
		rp=$(realpath "$1")
		if [ "$rp" != "$1" ]; then
			echo "                            [$rp]"
		fi
	fi
}

# report: print the current state of the configuration variables
report() {
	echo "kernel directory            $ksrc"
	print_realpath "$ksrc"
	local v=$lin_ver
	[ -n "$v" ] || v="-"
	echo -n "linux version               $v"
	if [ -n "$lin_ver" ] && with perl; then
		echo " [$(scripts/vers $lin_ver -C)]"
	else
		echo
	fi
	if [ -n "$nodrivers" ]; then
		echo "no-drivers"
	else
		echo "kernel sources              $src"
		print_realpath "$src"
		local d=$s_drivers
		[ -n "$d" ] || d="-"
		echo "drivers                     $d"
		echo
		if [ -n "$(echo $patches)" ]; then
			echo -e "Selected patches:\n\n$patches"
		fi
	fi
}

# error [line line...]: format an error msg containing the provided lines
# 			and exit with failure.
error() {
	{
		cat <<-EOF
*********************************** ERROR ***********************************
		EOF
		sed 's/^/*** /' # output the error message from stdin
		cat <<-EOF
***
***
***     Current configuration values:
***
		EOF
		report | sed 's/^/*** /'
		cat <<-EOF
*****************************************************************************
		EOF
	} | tee -a config.log
	exit 1
}

# print_help
print_help() {
	cat <<-EOF
Available options:

  --help                       print this message
  --kernel-dir=                path to configured kernel directory
  --kernel-sources=            path to full kernel sources
  --kernel-opts=	       additional options to pass to kernel make
                               (you can call this several times)
  --install-mod-path=          where the modules will be installed
  --driver-suffix=             add suffix to the patched modules names
  --no-drivers                 do not compile patched drivers

  --cc=                        C compiler for the examples [$cc]
  --ld=                        linker for the examples [$ld]
  --prefix=                    install path for the examples [$prefix]
  --destir=                    destination dir for the examples [$DESTDIR]
	EOF
}

#################################################################
# machinery for the creation of netmap_linux_config.h           #
#################################################################

# We check for the availability/version of several linux
# internal APIs by running compilation tests. The results
# of the tests will produce a set of macros in the
# 'netmap_linux_config.h' file. All macros names begin
# with 'NETMAP_LINUX'.

# TMPDIR is where we build all the tests
TMPDIR=netmap-tmpdir
rm -rf $TMPDIR
mkdir $TMPDIR

# tests are first accumulated using add_named_test and add_test, then
# run by run_tests. This setup amortizes the cost of going
# through linux kbuild and opens the opportunity of using the '-j'
# flag of make. Speedup is in the order of x10.

# TESTOBJS will contain the list of test modules to build
TESTOBJS=
# TESTPOSTPROC will contain a script that runs the pertinent
# 'on success' or 'on failure' action for each test at the
# end of 'run_tests'.
TESTPOSTPROC=

# add_named_test <test-name> [<on success> [<on failure>]]:
#     the test code is read from stdin, completed with
#     some standard modules boiler plate and put in
#     $TMPDIR/test-name.c for future compilation by 'run_tests'.
#     The optional <on success> script (which must be a single
#     argument) will be executed if $TMPDIR/test-name.o will
#     be correctly created. The optional <on failure>
#     script (one argument) will be executed if compilation fails.
#
#     Note: add_test (below) is preferred. Use add_named_test
#     only if you need to do some complex check for which you need to
#     know the name of the test files.
add_named_test() {
	{
		cat <<-EOF
			#include <linux/module.h>
			#include <linux/kernel.h>
			#include <linux/init.h>
		EOF
		cat	# output the test code read from stdin
	} > $TMPDIR/$1.c
	# add the module to the running list
	TESTOBJS="$1.o $TESTOBJS"
	# add the postprocess script for this test
	if [ -n "$2" ]; then
		cmd="if [ -f $TMPDIR/$1.o ]; then $2"
		[ -n "$3" ] && cmd="$cmd; else $3"
		cmd="$cmd; fi"
		TESTPOSTPROC="$cmd; $TESTPOSTPROC"
	fi
}

# add_test [<on success> [<on failure>]]
#     used like add_named_test above, but without the need of
#     explicitly naming the test.
NEXTTEST=1
add_test() {
	local t="__test__$NEXTTEST"
	add_named_test $t "$@"
	: $((NEXTTEST++))
}

# run_tests: run all accumulated tests and exec the pertinent
#   success/failure actions for each one.
run_tests() {
	local t= 	# prevent -EOF to eat the make TAB
	cat > $TMPDIR/Makefile <<-EOF
		ifneq (\$(KERNELRELEASE),)
		obj-m := $TESTOBJS
		else
		all: $get_drivers
		$t	\$(MAKE) -C $ksrc M=\$\$PWD

		-include $TOPDIR/drivers.mak
		endif
	EOF
	(
		cd $TMPDIR
		make -k -j $(grep -c processor /proc/cpuinfo)
	) >> config.log
	eval "$TESTPOSTPROC"
}

configh=netmap_linux_config.h
# succes/failure actions are expected to write some macros
# in netma_linux_config.h. The following functions can be
# used to simplify the task.

# define <macro> <value>: define NETMAP_LINUX_<macro> as <value>
define() {
	cat >> $configh <<-EOF

		#define NETMAP_LINUX_$1 $2
	EOF
}

# have <macro>: define NETMAP_LINUX_HAVE_<macro>
have() {
	define "HAVE_$1"
}


####################################################################
################### START OF PROCESSING ############################
####################################################################

rm -f config.log
{
	echo "# netmap configure log $(date)"
	echo "# Configured with:"
	printf " '%s'" "$0" "$@"
	echo
	echo "#"
} > config.log

exec 2>> config.log
set -x

############################
# parse options
############################
ksrc=
src=
nodrivers=
kopts=
modpath=
drvsuffix=
# get ksrc and src before anything else
for opt do
	optarg=${opt#*=}
	case "$opt" in
	--kernel-dir=*) ksrc="$optarg"
	;;
	--kernel-sources=*) src="$optarg"
	;;
	--kernel-opts=*) kopts="$kopts $optarg"
	;;
	--install-mod-path=*) modpath="$optarg"
	;;
	--driver-suffix=*) drvsuffix="$optarg"
	;;
	--no-drivers) nodrivers="true"
	;;
	--cc=*) cc="$optarg"
	;;
	--ld=*) ld="$optarg"
	;;
	--prefix=*) prefix="$optarg"
	;;
	--destdir=*) DESTDIR="$optarg"
	;;
	--help)
		print_help
		exit
	;;
	*)
		echo "WARNING: Unrecognized option: $opt"
	;;
	esac
done

################################
# check for sane configuration
################################

[ -n "$ksrc" ] || {
	# user did not provide a kernel dir,
	# we try to find one by ourselves
	ksrc="/lib/modules/$(uname -r)/build"
}

[ -n "$src" ] || {
	[ -d "$ksrc/source" ] && src="$ksrc/source"
	[ -n "$src" ] || src=$ksrc
}

if [ ! -d "$ksrc" ]; then
	error <<-EOF
Cannot find kernel directory.

We need at least the kernel headers to compile the netmap kernel module.
If your kernel headers are not in the standard place, please provide the
correct path using the

    --kernel-dir=/path/to/kernel/dir

option.

Otherwise, check that the 'build' symlink in

    /lib/modules/\$(uname -r)

is not broken.
	EOF
fi
version_hdr="$ksrc/include/linux/version.h"
[ -f "$version_hdr" ] || version_hdr="$ksrc/include/generated/uapi/linux/version.h"
if [ ! -f "$ksrc/.config" ] || [ ! -f "$version_hdr" ]; then
	error <<-EOF
kernel not configured.

The kernel directory must be ready for external module compilation.
You may need to issue the following or equivalent commands:

    cd $ksrc
    make oldconfig
    make modules_prepare
	EOF
fi
lin_ver=$(awk '/LINUX_VERSION_CODE/ { printf "%03x%02x", $3/256, $3%256}' "$version_hdr")

if [ -z "$nodrivers" ]; then
	if [ ! -d "$src" ] ||
	   [ -z "$(find "$src/drivers" -name '*.c' -print -quit)" ]; then
		error <<-EOF
Cannot find full kernel sources.

We need the full kernel sources to build the netmap-enabled drivers.
Please note that most distributions provide separate packages for kernel
headers and sources. Once you know the path to kernel sources, you can
rerun this script with the additional

    --kernel-sources=/path/to/sources

option.

If you are only interested in VALE and pipes, you can rerun the script
now with the '--no-drivers' option. Hardware devices will then be accessed
via a generic adapter at reduced performance."
		EOF
	fi
fi


###############################################################
# Makefile creation
###############################################################

# here we select the patches for the drivers and create the
# main Makefile. The Makefile is obtained from Makefile.in
# with some values replaced in (mainly the kernel directory).
# The final Makefile will include drivers.mak, which is also
# created here. drivers.mak will contain a get-driver and
# clear-driver target for each of the available drivers.

patches=
s_drivers=
get_drivers=
clean_drivers=
mod_list=
if [ -z "$nodrivers" ]; then
	# produce a list of applicable patches for this version
	[ -d patches ] || { rm -f patches; ln -s final-patches patches; }
	# the selection is based only on the kernel version
	patches=$(cd patches; ls diff--* | awk -v v=$lin_ver -F -- '($3 <= v"") && (v"" < $4)')
fi

rm -f drivers.mak
source $ksrc/.config
for p in $patches; do
	# extract the driver name
	driver=$(echo $p | awk -F -- '{ print $2 }')
	# find the driver sources
	s=$(find $src/drivers/ -name "$driver" -print -quit)
	[ -n "$s" ] || { echo "WARNING: $driver sources not found"; continue; }
	drv_conf="CONFIG_$(basename $driver .c | tr a-z A-Z)"
	[ "${!drv_conf}" = m ] || {
		echo "WARNING: $drv_conf=m not set in $ksrc/.config, skipping $driver"
		continue
	}
	mod_list="$drv_conf=m $mod_list"
	# add the driver related targets to drivers.mak
	$t=	# prevent -EOF to eat the make TAB
	cat >> drivers.mak <<-EOF
		get-$driver:
		$t	cp -Rp $s .
		$t	if [ -f patches/$p ]; then patch --posix --quiet --force -p1 < patches/$p; fi
	EOF
	if [ -d $s ]; then
		d=$(basename $s)
		cat >> drivers.mak <<-EOF
			$t	if [ -f drv-subdir.mak ]; then mv $d/Makefile $d/orig.mak; cp drv-subdir.mak $d/Makefile; fi
		EOF
	fi
	cat >> drivers.mak <<-EOF
		$t	touch get-$driver

		clean-$driver:
		$t	rm -rf $driver get-$driver

	EOF
	s_drivers="$driver $s_drivers"
	get_drivers="get-$driver $get_drivers"
	clean_drivers="clean-$driver $clean_drivers"
done
# add some convenience cumulative targets
cat >> drivers.mak <<-EOF
	.PHONY: get-drivers clean-drivers
	get-drivers: $get_drivers
	clean-drivers: $clean_drivers
EOF

# create Makefile
sed \
	-e "s|@KSRC@|$ksrc|g" \
	-e "s|@SRC@|$src|g" \
	-e "s|@KOPTS@|$kopts|g" \
	-e "s|@MODPATH@|$modpath|g" \
	-e "s|@LIN_VER@|$lin_ver|g" \
	-e "s|@MOD_LIST@|$mod_list|g" \
	-e "s|@PATCHES@|$(echo $patches)|g" \
	-e "s|@S_DRIVERS@|$(echo $s_drivers)|g" \
	-e "s|@DRVSUFFIX@|$drvsuffix|g" \
	-e "s|@APPS_CC@|$cc|g" \
	-e "s|@APPS_LD@|$ld|g" \
	-e "s|@PREFIX@|$prefix|g" \
	-e "s|@DESTDIR@|$DESTDIR|g" \
	Makefile.in > Makefile


#################################################
# create the config.h file
#################################################

# BEGIN_TESTS

# iommu support
add_test 'have IOMMU' <<-EOF
	#include <linux/iommu.h>

	void dummy(void)
	{
	        struct iommu_group *grp = iommu_group_get(NULL);
	        int id = iommu_group_id(grp);

	        (void)grp;
	        (void)id;
	}
EOF

# return value of hrtimer handler
add_test 'define TIMER_RTYPE "enum hrtimer_restart"' 'define TIMER_RTYPE int' <<-EOF
	#include <linux/hrtimer.h>

	enum hrtimer_restart
	testmod_timer_handler(struct hrtimer *t)
	{
	        (void)t;
	        return HRTIMER_RESTART;
	}
EOF

# rx_register (intercept packets in the generic adapter)
add_test 'have RX_REGISTER' <<-EOF
	#include <linux/netdevice.h>

	int dummy(void)
	{
	        return netdev_rx_handler_register(NULL, NULL, NULL);
	}
EOF

# rx_handler_result_t
add_test 'have RX_HANDLER_RESULT' <<-EOF
	#include <linux/netdevice.h>


	static rx_handler_result_t dummy_rx_handler(struct sk_buf **pm)
	{
	        (void)pm;
	        return RX_HANDLER_PASS;
	}

	int dummy(void)
	{
	        return netdev_rx_handler_register(NULL, dummy_rx_handler, NULL);
	}
EOF

# number of parameters in ndo_select_queue
# (we expect at most one of these to succeed)
params="NULL, NULL"
for n in 2 3 4; do
	add_test "define SELECT_QUEUE $n" <<-EOF
		#include <linux/netdevice.h>

		u16 dummy(struct net_device_ops *ndo)
		{
		        return ndo->ndo_select_queue($params);
		}
	EOF
	params="NULL, $params"
done

# ethtool get_ringparam
add_test 'have GET_RINGPARAM' <<-EOF
	#include <linux/netdevice.h>
	#include <linux/ethtool.h>

	void
	dummy(struct net_device *net, struct ethtool_ringparam *rp) {
	        net->ethtool_ops->get_ringparam(net, rp);
	}
EOF

# number of tx/rx queues
add_test 'have NUM_QUEUES' <<-EOF
	#include <linux/netdevice.h>

	void
	dummy(struct net_device *net, unsigned int *txq, unsigned int *rxq)
	{
	    *txq = net->real_num_tx_queues;
	    *rxq = net->real_num_rx_queues;
	}
EOF

# poll_table key field
for k in _key key; do
	add_test "define PWAIT_KEY $k" <<-EOF
		#include <linux/poll.h>

		int
		dummy(struct poll_table_struct *pwait)
		{
		        return pwait->$k;
		}
	EOF
done

# check for unlocked_ioctl
add_test 'have UNLOCKED_IOCTL' <<-EOF
	#include <linux/fs.h>

	void *
	dummy(struct file_operations *fops)
	{
	        return fops->unlocked_ioctl;
	}
EOF

# check for init_net
add_test 'have INIT_NET' <<-EOF
	#include <linux/netdevice.h>

	struct net_device *
	dummy(const char *name)
	{
	        return dev_get_by_name(&init_net, name);
	}
EOF

# check for skb_copy_to_linear_data*
add_test 'have SKB_COPY_LINEAR' <<-EOF
	#include <linux/skbuff.h>

	void dummy(struct sk_buff *skb, const void *from, const unsigned int len)
	{
	        skb_copy_to_linear_data(skb, from, len);
	}
EOF

# check for ACCESS_ONCE
add_test 'have ACCESS_ONCE' <<-EOF
	#include <linux/compiler.h>

	int dummy(int *p)
	{
	        return ACCESS_ONCE(*p);
	}
EOF

# check for uintptr_t
add_test 'have UINTPTR' <<-EOF
	uintptr_t dummy;
EOF

# check for queue_mapping
add_test 'have QUEUE_MAPPING' <<-EOF
	#include <linux/skbuff.h>

	u16 dummy(const struct sk_buff *skb)
	{
	        return skb_get_queue_mapping(skb);
	}
EOF

# check for hrtimer_forward_now
add_test 'have HRTIMER_FORWARD_NOW' <<-EOF
	#include <linux/hrtimer.h>

	u64 dummy(struct hrtimer *timer, ktime_t interval)
	{
	        return hrtimer_forward_now(timer, interval);
	}
EOF

# check for phys_addr_t
add_test 'have PHYS_ADDR_T' <<-EOF
	#include <linux/types.h>

	phys_addr_t dummy;
EOF

# check for net_device_ops
add_test 'have NETDEV_OPS' <<-EOF
	#include <linux/netdevice.h>

	struct net_device_ops dummy;
EOF

# check for netdev_tx_t
add_test 'have NETDEV_TX_T' <<-EOF
	#include <linux/netdevice.h>

	netdev_tx_t dummy;
EOF

# check for usleep_range
add_test 'have USLEEP_RANGE' <<-EOF
	#include <linux/delay.h>

	void dummy(void)
	{
	        usleep_range(0, 0);
	}
EOF

# check for exported split_page
add_test 'have SPLIT_PAGE' <<-EOF
	#include <linux/mm.h>

	void dummy(struct page *page, unsigned int order)
	{
	        return split_page(page, order);
	}
EOF

# check for HRTIMER_MODE_REL
add_test 'have HRTIMER_MODE_REL' <<-EOF
	#include <linux/hrtimer.h>

	void dummy(struct hrtimer *timer, clockid_t which_clock)
	{
	        hrtimer_init(timer, which_clock, HRTIMER_MODE_REL);
	}
EOF

# check for IFF_LIVE_ADDR_CHANGE
add_test 'have LIVE_ADDR_CHANGE' <<-EOF
	#include <linux/netdevice.h>

	int dummy = IFF_LIVE_ADDR_CHANGE;
EOF

# check for ndo_get_stats64
add_test 'have GET_STATS64' <<-EOF
	#include <linux/netdevice.h>

	void * dummy(struct net_device_ops *ops) {
	       return ops->ndo_get_stats64;
	}
EOF

# check for IFF_TX_SKB_SHARING
add_test 'have TX_SKB_SHARING' <<-EOF
	#include <linux/netdevice.h>

	int dummy = IFF_TX_SKB_SHARING;
EOF

# check for hw_features in net_device
add_test 'have HW_FEATURES' <<-EOF
	#include <linux/netdevice.h>

	struct net_device *n;
        (void)n->hw_features;
EOF

# check for eth_hw_addr_random
add_test 'have ADDR_RANDOM' <<-EOF
	#include <linux/etherdevice.h>

	void dummy(struct net_device *dev) {
	        eth_hw_addr_random(dev);
	}
EOF


# e1000e
add_test 'have E1000E_HWADDR' <<-EOF
	#include "e1000e/e1000.h"

	void* dummy(struct e1000_adapter *adapter,
	        struct e1000_ring *ring)
	{
		return adapter->hw.hw_addr + ring->tail;
	}
EOF

add_test 'have E1000E_DOWN2' <<-EOF
	#include "e1000e/e1000.h"

	void dummy(struct e1000_adapter *adapter)
	{
		e1000e_down(adapter, false);
	}
EOF

add_test "grep -q '\<e1000_rx_desc_extended\>' $TMPDIR/e1000e/netdev.c \
	&& have E1000E_EXT_RXDESC" </dev/null

# rtl8169
add_test 'define RTL_OPEN rtl8169_open' 'define RTL_OPEN rtl_open' <<-EOF
	#include "r8169.c"

	static int dummy(struct net_device *dev) {
		return rtl8169_open(dev);
	}
EOF

add_test 'have RTL_WFQ' <<-EOF
	#include "r8169.c"

	static void dummy(struct net_device *dev) {
		rtl8169_wait_for_quiescence(dev);
	}
EOF

# END_TESTS

# now we actually create the file

rm -f $configh
cat > $configh <<-EOF
	#ifndef NETMAP_LINUX_CONFIG_H
	#define NETMAP_LINUX_CONFIG_H
EOF

# the TESTPOSTPROC script will add macros to $configh
run_tests

define DRIVER_SUFFIX \"$drvsuffix\"

# file end
cat >> $configh <<-EOF

	#endif
EOF


report

# config.status can be used to rerun configure with the
# same arguments
rm -f config.status
{ printf " '%s'" "$0" "$@"; echo; } > config.status
chmod +x config.status
