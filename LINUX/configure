#!/bin/bash

with() {
	type $1 >/dev/null 2>&1
}

report() {
	echo "kernel directory            $ksrc"
	if with realpath; then
		rksrc=$(realpath "$ksrc")
		if [ "$ksrc" != "$rksrc" ]; then
			echo "                            [$rksrc]"
		fi
	fi
	local v=$lin_ver
	[ -n "$v" ] || v="-"
	echo -n "linux version               $v"
	if [ -n "$lin_ver" ] && with perl; then
		echo " [$(scripts/vers $lin_ver -C)]"
	else
		echo
	fi
	if [ -n "$nodrivers" ]; then
		echo "no-drivers"
	else
		echo "kernel sources              $src"
		if with realpath; then
			rsrc=$(realpath "$src")
			if [ "$src" != "$rsrc" ]; then
				echo "                            [$rsrc]"
			fi
		fi
		local d=$s_drivers
		[ -n "$d" ] || d="-"
		echo "drivers                     $d"
		echo
		if [ -n "$(echo $patches)" ]; then
			echo -e "Selected patches:\n\n$patches"
		fi
	fi
}

error() {
	{
		local line
		echo "*********************************** ERROR ***********************************"
		for line; do
			echo "*** "$line
		done
		echo "***"
		echo
		echo "     Current configuration values:"
		echo
		report
		echo "*****************************************************************************"
	} | tee -a config.log
	exit 1
}

print_help() {
	echo "  --help                       print this message"
	echo "  --kernel-dir                 path to configured kernel directory"
	echo "  --kernel-sources             path to full kernel sources"
	echo "  --no-drivers                 do not compile patched drivers"
}

TMPDIR=netmap-tmpdir
rm -rf $TMPDIR
mkdir $TMPDIR

TESTOBJS=
TESTPOSTPROC=
add_named_test() {
	{
		cat <<EOF
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
EOF
		cat
		cat <<EOF

MODULE_LICENSE("GPL");
MODULE_AUTHOR("netmap");
MODULE_DESCRIPTION("module $1");

static int __init $1_init(void)
{
	return 0;
}

module_init($1_init);
EOF
	} > $TMPDIR/$1.c
	TESTOBJS="$1.o $TESTOBJS"
	if [ -n "$2" ]; then
		cmd="if [ -f $TMPDIR/$1.o ]; then $2"
		[ -n "$3" ] && cmd="$cmd; else $3"
		cmd="$cmd; fi"
		TESTPOSTPROC="$cmd; $TESTPOSTPROC"
	fi
}

NEXTTEST=1
add_test() {
	local t="__test__$NEXTTEST"
	add_named_test $t "$@"
	: $((NEXTTEST++))
}

run_tests() {
	cat > $TMPDIR/Makefile <<EOF
ifneq (\$(KERNELRELEASE),)
obj-m := $TESTOBJS
else
all:
	\$(MAKE) -C $ksrc M=\$\$PWD
endif
EOF
	(
		cd $TMPDIR
		make -k -j $(grep -c processor /proc/cpuinfo)
	) >> config.log
	eval "$TESTPOSTPROC"
}


configh=netmap_linux_config.h
have() {
	cat >> $configh <<EOF

#define NETMAP_LINUX_HAVE_$1
EOF
}

define() {
	cat >> $configh <<EOF

#define NETMAP_LINUX_$1 $2
EOF
}

rm -f config.log


{
	echo "# netmap configure log $(date)"
	echo "# Configured with:"
	printf " '%s'" "$0" "$@"
	echo
	echo "#"
} > config.log

exec 2>> config.log
set -x

ksrc=
src=
nodrivers=
# get ksrc and src before anything else
for opt do
	optarg=${opt#*=}
	case "$opt" in
	--kernel-dir=*) ksrc="$optarg"
	;;
	--kernel-sources=*) src="$optarg"
	;;
	--no-drivers) nodrivers="true"
	;;
	--help)
		print_help
		exit
	;;
	*)
		echo "WARNING: Unrecognized option: $opt"
	;;
	esac
done

[ -n "$ksrc" ] || {
	# user did not provide a kernel dir,
	# we try to find one by ourselves
	ksrc="/lib/modules/$(uname -r)/build"
}

[ -n "$src" ] || {
	[ -d "$ksrc/source" ] && src="$ksrc/source"
	[ -n "$src" ] || src=$ksrc
}

if [ ! -d "$ksrc" ]; then
	error "Cannot find kernel directory." \
	      "" \
	      "We need at least the kernel headers to compile the netmap kernel module." \
	      "If your kernel headers are not in the standard place, please provide " \
	      "the correct path  using the '--kernel-dir=...' option." \
	      "Otherwise, check that the 'build' symlink in /lib/modules/... is not broken."
fi
version_hdr="$ksrc/include/linux/version.h"
[ -f "$version_hdr" ] || version_hdr="$ksrc/include/generated/uapi/linux/version.h"
if [ ! -f "$ksrc/.config" ] || [ ! -f "$version_hdr" ]; then
	error "kernel not configured." \
	      "" \
	      "The kernel directory must be ready for external module compilation. " \
	      "You may need to issue the following or equivalent commands: "\
	      "" \
	      "  cd $ksrc" \
	      "  make oldconfig" \
	      "  make modules_prepare"
fi
lin_ver=$(awk '/LINUX_VERSION_CODE/ { printf "%03x%02x", $3/256, $3%256}' "$version_hdr")

if [ -z "$nodrivers" ]; then
	if [ ! -d "$src" ] || [ -z "$(find "$src/drivers" -name '*.c' -print -quit)" ]; then
		error "Cannot find full kernel sources." \
		      "" \
		      "We need the full kernel sources to build the netmap-enabled drivers. " \
		      "Please note that most distributions provide separate packages for " \
		      "kernel headers and sources. Once you know the path to kernel sources, " \
		      "you can rerun this script with the additional " \
		      "   --kernel-sources=/path/to/sources " \
		      "option. "\
		      "" \
		      "If you are only interested in VALE and pipes, you can rerun the script " \
		      "now with the '--no-drivers' option. Hardware devices will then be " \
		      "accessed via a generic adapter at reduced performance."
	fi
fi


#################################################
# create the config.h file
#################################################

# iommu support
add_test <<EOF 'have IOMMU'
#include <linux/iommu.h>

void dummy(void)
{
	struct iommu_group *grp = iommu_group_get(NULL);
	int id = iommu_group_id(grp);

	(void)grp;
	(void)id;
}
EOF

# return value of hrtimer handler
add_test <<EOF 'define TIMER_RTYPE "enum hrtimer_restart"' 'define TIMER_RTYPE int'
#include <linux/hrtimer.h>

enum hrtimer_restart
testmod_timer_handler(struct hrtimer *t)
{
	(void)t;
	return HRTIMER_RESTART;
}
EOF

# rx_register (intercept packets in the generic adapter)
add_test <<EOF 'have RX_REGISTER'
#include <linux/netdevice.h>

int dummy(void)
{
	return netdev_rx_handler_register(NULL, NULL, NULL);
}
EOF

# rx_handler_result_t
add_test <<EOF 'have RX_HANDLER_RESULT'
#include <linux/netdevice.h>


static rx_handler_result_t dummy_rx_handler(struct sk_buf **pm)
{
	(void)pm;
	return RX_HANDLER_PASS;
}

int dummy(void)
{
	return netdev_rx_handler_register(NULL, dummy_rx_handler, NULL);
}
EOF

# number of parameters in ndo_select_queue
params="NULL, NULL"
for n in 2 3 4; do
	add_named_test ndo_select_queue$n <<EOF
	#include <linux/netdevice.h>

	u16 dummy(struct net_device_ops *ndo)
	{
		return ndo->ndo_select_queue($params);
	}
EOF
	params="NULL, $params"
done

# ethtool get_ringparam
add_test <<EOF 'have GET_RINGPARAM'
#include <linux/netdevice.h>
#include <linux/ethtool.h>

void
dummy(struct net_device *net, struct ethtool_ringparam *rp) {
	net->ethtool_ops->get_ringparam(net, rp);
}
EOF

# number of tx/rx queues
add_test <<EOF 'have NUM_QUEUES'
#include <linux/netdevice.h>

void
dummy(struct net_device *net, unsigned int *txq, unsigned int *rxq)
{
    *txq = net->real_num_tx_queues;
    *rxq = net->real_num_rx_queues;
}
EOF

# poll_table key field
for k in _key key; do
	add_named_test poll_table_$k <<EOF
	#include <linux/poll.h>

	int
	dummy(struct poll_table_struct *pwait)
	{
		return pwait->$k;
	}
EOF
done

# check for unlocked_ioctl
add_test <<EOF 'have UNLOCKED_IOCTL'
#include <linux/fs.h>

void *
dummy(struct file_operations *fops)
{
	return fops->unlocked_ioctl;
}
EOF

# check for init_net
add_test <<EOF 'have INIT_NET'
#include <linux/netdevice.h>

struct net_device *
dummy(const char *name)
{
	return dev_get_by_name(&init_net, name);
}
EOF

# check for skb_copy_to_linear_data*
add_test <<EOF 'have SKB_COPY_LINEAR'
#include <linux/skbuff.h>

void dummy(struct sk_buff *skb, const void *from, const unsigned int len)
{
	skb_copy_to_linear_data(skb, from, len);
}
EOF

# check for ACCESS_ONCE
add_test <<EOF 'have ACCESS_ONCE'
#include <linux/compiler.h>

int dummy(int *p)
{
	return ACCESS_ONCE(*p);	
}
EOF

# check for uintptr_t
add_test <<EOF 'have UINTPTR'
uintptr_t dummy;
EOF

# check for queue_mapping
add_test <<EOF 'have QUEUE_MAPPING'
#include <linux/skbuff.h>

u16 dummy(const struct sk_buff *skb)
{
	return skb_get_queue_mapping(skb);
}
EOF

# check for hrtimer_forward_now
add_test <<EOF 'have HRTIMER_FORWARD_NOW'
#include <linux/hrtimer.h>

u64 dummy(struct hrtimer *timer, ktime_t interval)
{
	return hrtimer_forward_now(timer, interval);
}
EOF

# check for phys_addr_t
add_test <<EOF 'have PHYS_ADDR_T'
#include <linux/types.h>

phys_addr_t dummy;
EOF

# check for net_device_ops
add_test <<EOF 'have NETDEV_OPS'
#include <linux/netdevice.h>

struct net_device_ops dummy;
EOF

# check for netdev_tx_t
add_test <<EOF 'have NETDEV_TX_T'
#include <linux/netdevice.h>

netdev_tx_t dummy;
EOF

# check for usleep_range
add_test <<EOF 'have USLEEP_RANGE'
#include <linux/delay.h>

void dummy(void)
{
	usleep_range(0, 0);
}
EOF

# check for exported split_page
add_test <<EOF 'have SPLIT_PAGE'
#include <linux/mm.h>

void dummy(struct page *page, unsigned int order)
{
	return split_page(page, order);
}
EOF

# check for HRTIMER_MODE_REL
add_test <<EOF 'have HRTIMER_MODE_REL'
#include <linux/hrtimer.h>

void dummy(struct hrtimer *timer, clockid_t which_clock)
{
	hrtimer_init(timer, which_clock, HRTIMER_MODE_REL);
}
EOF

rm -f $configh
cat > $configh <<EOF
#ifndef NETMAP_LINUX_CONFIG_H
#define NETMAP_LINUX_CONFIG_H
EOF

run_tests

for n in 2 3 4; do
	if [ -f $TMPDIR/ndo_select_queue$n.o ]; then
		define SELECT_QUEUE $n
		break
	fi
done

for k in _key key; do
	if [ -f $TMPDIR/poll_table_$k.o ]; then
		define PWAIT_KEY $k
		break
	fi
done

# file end
cat >> $configh <<EOF

#endif
EOF
#################################################

patches=
s_drivers=
get_drivers=
clean_drivers=
if [ -z "$nodrivers" ]; then
	# produce a list of applicable patches for this version
	[ -d patches ] || { rm -f patches; ln -s final-patches patches; }
	patches=$(cd patches; ls diff--* | awk -v v=$lin_ver -F -- '($3 <= v"") && (v"" < $4)')
fi

rm -f drivers.mak
for p in $patches; do
	# extract the driver name
	driver=$(echo $p | awk -F -- '{ print $2 }')
	# find the driver sources
	s=$(find $src/drivers/ -name "$driver" -print -quit)
	[ -n "$s" ] || { echo "WARNING: $driver sources not found"; continue; }
	cat >> drivers.mak <<EOF
get-$driver:
	cp -Rp $s .
	patch --posix --quiet --force -p1 < patches/$p
	touch get-$driver

clean-$driver:
	rm -rf $driver get-$driver

EOF
	s_drivers="$driver $s_drivers"
	get_drivers="get-$driver $get_drivers"
	clean_drivers="clean-$driver $clean_drivers"
done
cat >> drivers.mak <<EOF
.PHONY: get-drivers clean-drivers
get-drivers: $get_drivers
clean-drivers: $clean_drivers
EOF

# create Makefile
sed \
	-e "s|@KSRC@|$ksrc|g" \
	-e "s|@SRC@|$src|g" \
	-e "s|@LIN_VER@|$lin_ver|g" \
	-e "s|@NODRIVERS@|$nodrivers|g" \
	-e "s|@PATCHES@|$(echo $patches)|g" \
	-e "s|@S_DRIVERS@|$(echo $s_drivers)|g" \
	Makefile.in > Makefile


report

rm -f config.status
{ printf " '%s'" "$0" "$@"; echo; } > config.status
chmod +x config.status
