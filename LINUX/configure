#!/bin/bash

error() {
	echo "ERROR: $1" | tee -a config.log
	exit 1
}

print_help() {
	echo "  --help                       print this message"
	echo "  --kernel-dir                 path to configured kernel directory"
	echo "  --kernel-sources             path to full kernel sources"
	echo "  --no-drivers                 do not compile patched drivers"
}

TMPDIR=netmap-tmpdir
TESTMOD=testmod
TMPC=netmap-tmp.c
compile() {
	rm -rf $TMPDIR
	mkdir -p $TMPDIR
	cat > $TMPDIR/Makefile <<EOF
ifneq (\$(KERNELRELEASE),)
obj-m := $TESTMOD.o
else
all:
	\$(MAKE) -C $ksrc M=\$\$PWD
endif
EOF
	{
		cat <<EOF
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
EOF
		f=$1
		[ -n "$f" ] || f=$TMPC
		[ -f "$f" ] && cat $f
		cat <<EOF
MODULE_LICENSE("GPL");
MODULE_AUTHOR("netmap");
MODULE_DESCRIPTION("test module");

static int __init testmod_init(void)
{
	return 0;
}

static void __exit testmod_cleanup(void)
{
}

module_init(testmod_init);
module_exit(testmod_cleanup);
EOF
	} > $TMPDIR/$TESTMOD.c
	(
		cd $TMPDIR
		echo "************* compiling *************"
		cat $TESTMOD.c
		echo "*************************************"
		make
	) >> config.log
}

configh=netmap_linux_config.h
have() {
	cat >> $configh <<EOF

#define NETMAP_LINUX_HAVE_$1
EOF
}

define() {
	cat >> $configh <<EOF

#define NETMAP_LINUX_$1 $2
EOF
}

rm -f config.log


{
	echo "# netmap configure log $(date)"
	echo "# Configured with:"
	printf " '%s'" "$0" "$@"
	echo
	echo "#"
} > config.log

exec 2>> config.log
set -x

ksrc=
src=
nodrivers=
# get ksrc and src before anything else
for opt do
	optarg=${opt#*=}
	case "$opt" in
	--kernel-dir=*) ksrc="$optarg"
	;;
	--kernel-sources=*) src="$optarg"
	;;
	--no-drivers) nodrivers="true"
	;;
	--help)
		print_help
		exit
	;;
	*)
		echo "WARNING: Unrecognized option: $opt"
	;;
	esac
done

[ -n "$ksrc" ] || {
	# user did not provide a kernel dir,
	# we try to find one by ourselves
	ksrc="/lib/modules/$(uname -r)/build"
}

[ -n "$src" ] || {
	[ -d "$ksrc/source" ] && src="$ksrc/source"
	[ -n "$src" ] || src=$ksrc
}

[ -d "$ksrc" ] || error "Cannot find kernel directory"
[ -f "$ksrc/.config" ] || error "kernel not configured"
version_hdr="$ksrc/include/linux/version.h"
[ -f "$version_hdr" ] || version_hdr="$ksrc/include/generated/uapi/linux/version.h"
[ -f "$version_hdr" ] || error "version.h is missing"
lin_ver=$(awk '/LINUX_VERSION_CODE/ { printf "%03x%02x", $3/256, $3%256}' "$version_hdr")


# check that the build system is sane
rm -f $TMPC
compile || error "Unable to build external modules"


#################################################
# create the config.h file
#################################################
rm -f $configh
cat > $configh <<EOF
#ifndef NETMAP_LINUX_CONFIG_H
#define NETMAP_LINUX_CONFIG_H
EOF

cat > $TMPC <<EOF
#include <linux/iommu.h>

void dummy(void)
{
	struct iommu_group *grp = iommu_group_get(NULL);
	int id = iommu_group_id(grp);

	(void)grp;
	(void)id;
}
EOF
compile && have IOMMU

cat > $TMPC <<EOF
#include <linux/hrtimer.h>

enum hrtimer_restart
testmod_timer_handler(struct hrtimer *t)
{
	(void)t;
	return HRTIMER_RESTART;
}
EOF
if compile; then
	define TIMER_RTYPE 'enum hrtimer_restart'
else
	define TIMER_RTYPE 'int'
fi

cat >> $configh <<EOF

#endif
EOF
#################################################

patches=
s_drivers=
get_drivers=
clean_drivers=
if [ -z "$nodrivers" ]; then
	[ -d "$src" ] || error "Cannot find kernel sources"
	[ -n "$(find "$src/" -name '*.c' -print -quit)" ] ||
		error "'$src' does not appear to contain full kernel sources"
	# produce a list of applicable patches for this version
	[ -d patches ] || { rm -f patches; ln -s final-patches patches; }
	patches=$(cd patches; ls diff--* | awk -v v=$lin_ver -F -- '($3 <= v"") && (v"" < $4)')
fi

rm -f drivers.mak
for p in $patches; do
	# extract the driver name
	driver=$(echo $p | awk -F -- '{ print $2 }')
	# find the driver sources
	s=$(find $src/drivers/ -name "$driver" -print -quit)
	[ -n "$s" ] || { echo "WARNING: $driver sources not found"; continue; }
	cat >> drivers.mak <<EOF
get-$driver:
	cp -Rp $s .
	patch --posix --quiet --force -p1 < patches/$p
	touch get-$driver

clean-$driver:
	rm -rf $driver get-$driver

EOF
	s_drivers="$driver $s_drivers"
	get_drivers="get-$driver $get_drivers"
	clean_drivers="clean-$driver $clean_drivers"
done
cat >> drivers.mak <<EOF
.PHONY: get-drivers clean-drivers
get-drivers: $get_drivers
clean-drivers: $clean_drivers
EOF

# create Makefile
sed \
	-e "s|@KSRC@|$ksrc|g" \
	-e "s|@SRC@|$src|g" \
	-e "s|@LIN_VER@|$lin_ver|g" \
	-e "s|@NODRIVERS@|$nodrivers|g" \
	-e "s|@PATCHES@|$(echo $patches)|g" \
	-e "s|@S_DRIVERS@|$(echo $s_drivers)|g" \
	Makefile.in > Makefile


# report
echo "kernel directory            $ksrc"
echo "kernel sources              $src"
echo "linux version               $lin_ver"
echo -n "drivers                     "
if [ -n "$nodrivers" ]; then
	echo DISABLED
else
	echo $s_drivers
	echo
	echo -e "Selected patches:\n\n$patches"
fi

rm -f config.status
{ printf " '%s'" "$0" "$@"; echo; } > config.status
chmod +x config.status
