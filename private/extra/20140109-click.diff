diff --git a/elements/userlevel/fromdevice.cc b/elements/userlevel/fromdevice.cc
index 3da8dab..26f4299 100644
--- a/elements/userlevel/fromdevice.cc
+++ b/elements/userlevel/fromdevice.cc
@@ -471,15 +471,16 @@ FromDevice::netmap_dispatch()
 	struct netmap_ring *ring = NETMAP_RXRING(_netmap.nifp, ri);
 	//click_chatter("netmap dispatch %s %u %u %u %u", _ifname.c_str(), ri, ring->cur, ring->reserved, ring->avail);
 
-	while (ring->reserved > 0 && NetmapInfo::refill(ring))
+	while (ring->head != ring->cur && _netmap.refill(ring))
 	    /* click_chatter("Refilled") */;
 
-	if (ring->avail == 0)
+	if (nm_ring_empty(ring))
 	    continue;
 
-	int nzcopy = (int) (ring->num_slots / 2) - (int) ring->reserved;
+	// we let at most half a ring of zerocopy packets
+	int nzcopy = (int)(ring->num_slots / 2) - NetmapInfo::reserved(ring);
 
-	while (n != _burst && ring->avail > 0) {
+	while (n != _burst && !nm_ring_empty(ring)) {
 	    unsigned cur = ring->cur;
 	    unsigned buf_idx = ring->slot[cur].buf_idx;
 	    if (buf_idx < 2)
@@ -488,16 +489,15 @@ FromDevice::netmap_dispatch()
 
 	    WritablePacket *p;
 	    if (nzcopy > 0) {
-		p = Packet::make(buf, ring->slot[cur].len, NetmapInfo::buffer_destructor);
-		++ring->reserved;
+		p = Packet::make(buf, ring->slot[cur].len, NetmapInfo::buffer_destructor, (void *)&_netmap);
 		--nzcopy;
-	    } else {
+	    } else { // copy and release the buffer at ring->head
 		p = Packet::make(_headroom, buf, ring->slot[cur].len, 0);
-		unsigned res1idx = NETMAP_RING_FIRST_RESERVED(ring);
-		ring->slot[res1idx].buf_idx = buf_idx;
+		ring->slot[ring->head].buf_idx = buf_idx;
+		ring->slot[ring->head].flags = NS_BUF_CHANGED;
+		ring->head = nm_ring_next(ring, ring->head);
 	    }
-	    ring->cur = NETMAP_RING_NEXT(ring, ring->cur);
-	    --ring->avail;
+	    ring->cur = nm_ring_next(ring, cur);
 	    ++n;
 
 	    emit_packet(p, 0, ring->ts);
diff --git a/elements/userlevel/netmapinfo.cc b/elements/userlevel/netmapinfo.cc
index ca591f6..2dacebd 100644
--- a/elements/userlevel/netmapinfo.cc
+++ b/elements/userlevel/netmapinfo.cc
@@ -28,11 +28,6 @@
 CLICK_DECLS
 
 static Spinlock netmap_memory_lock;
-static void *netmap_memory = MAP_FAILED;
-static size_t netmap_memory_size;
-static uint32_t netmap_memory_users;
-
-unsigned char *NetmapInfo::buffers;
 
 int
 NetmapInfo::ring::open(const String &ifname,
@@ -54,32 +49,23 @@ NetmapInfo::ring::open(const String &ifname,
     req.nr_version = NETMAP_API;
 #endif
     int r;
-    if ((r = ioctl(fd, NIOCGINFO, &req))) {
-	initial_errh->error("netmap %s: %s", ifname.c_str(), strerror(errno));
+    if ((r = ioctl(fd, NIOCREGIF, &req))) {
+	errh->error("netmap register %s: %s", ifname.c_str(), strerror(errno));
     error:
 	close(fd);
 	return -1;
     }
-    size_t memsize = req.nr_memsize;
-
-    if ((r = ioctl(fd, NIOCREGIF, &req))) {
-	errh->error("netmap register %s: %s", ifname.c_str(), strerror(errno));
-	goto error;
-    }
 
     netmap_memory_lock.acquire();
-    if (netmap_memory == MAP_FAILED) {
-	netmap_memory_size = memsize;
-	netmap_memory = mmap(0, netmap_memory_size, PROT_WRITE | PROT_READ,
+    buffers = 0;
+    memsize = req.nr_memsize;
+    mem = (char *)mmap(0, memsize, PROT_WRITE | PROT_READ,
 			     MAP_SHARED, fd, 0);
-	if (netmap_memory == MAP_FAILED) {
-	    errh->error("netmap allocate %s: %s", ifname.c_str(), strerror(errno));
-	    netmap_memory_lock.release();
-	    goto error;
-	}
+    if (mem == MAP_FAILED) {
+	errh->error("netmap allocate %s: %s", ifname.c_str(), strerror(errno));
+	netmap_memory_lock.release();
+	goto error;
     }
-    mem = (char *) netmap_memory;
-    ++netmap_memory_users;
     netmap_memory_lock.release();
 
     nifp = NETMAP_IF(mem, req.nr_offset);
@@ -110,12 +96,11 @@ void
 NetmapInfo::ring::close(int fd)
 {
     netmap_memory_lock.acquire();
-    if (--netmap_memory_users <= 0 && netmap_memory != MAP_FAILED) {
-	munmap(netmap_memory, netmap_memory_size);
-	netmap_memory = MAP_FAILED;
+    if (mem != MAP_FAILED) {
+	munmap(mem, memsize);
+	mem = (char *)MAP_FAILED;
     }
     netmap_memory_lock.release();
-    ioctl(fd, NIOCUNREGIF, (struct nmreq *) 0);
     ::close(fd);
 }
 
diff --git a/elements/userlevel/netmapinfo.hh b/elements/userlevel/netmapinfo.hh
index be8acae..d436f51 100644
--- a/elements/userlevel/netmapinfo.hh
+++ b/elements/userlevel/netmapinfo.hh
@@ -12,36 +12,47 @@ class NetmapInfo { public:
 
     struct ring {
 	char *mem;
+	size_t memsize;
 	unsigned ring_begin;
 	unsigned ring_end;
 	struct netmap_if *nifp;
+	unsigned char *buffers;	// XXX released bufs, not thread safe
 
 	int open(const String &ifname,
 		 bool always_error, ErrorHandler *errh);
 	void initialize_rings_rx(int timestamp);
 	void initialize_rings_tx();
 	void close(int fd);
+	// XXX return a buffer to the ring
+	bool refill(struct netmap_ring *ring) {
+	    if (buffers) {
+		unsigned char *buf = buffers;
+		buffers = *reinterpret_cast<unsigned char **>(buffers);
+		unsigned res1idx = ring->head;
+		ring->slot[res1idx].buf_idx = NETMAP_BUF_IDX(ring, (char *) buf);
+		ring->slot[res1idx].flags |= NS_BUF_CHANGED;
+		ring->head = nm_ring_next(ring, res1idx);
+		return true;
+	    } else
+		return false;
+	}
     };
 
-    static unsigned char *buffers;	// XXX not thread safe
     static bool is_netmap_buffer(Packet *p) {
 	return p->buffer_destructor() == buffer_destructor;
     }
-    static void buffer_destructor(unsigned char *buf, size_t) {
-	*reinterpret_cast<unsigned char **>(buf) = buffers;
-	buffers = buf;
+    static void buffer_destructor(unsigned char *buf, size_t, void *arg) {
+	struct ring *ring = reinterpret_cast<struct ring *>(arg);
+	*reinterpret_cast<unsigned char **>(buf) = ring->buffers;
+	ring->buffers = buf;
     }
-    static bool refill(struct netmap_ring *ring) {
-	if (buffers) {
-	    unsigned char *buf = buffers;
-	    buffers = *reinterpret_cast<unsigned char **>(buffers);
-	    unsigned res1idx = NETMAP_RING_FIRST_RESERVED(ring);
-	    ring->slot[res1idx].buf_idx = NETMAP_BUF_IDX(ring, (char *) buf);
-	    ring->slot[res1idx].flags |= NS_BUF_CHANGED;
-	    --ring->reserved;
-	    return true;
-	} else
-	    return false;
+
+    // return number of reserved buffers
+    static int reserved(struct netmap_ring *ring) {
+	int ret = ring->cur - ring->head;
+	if (ret < 0)
+		ret += ring->num_slots;
+	return ret;
     }
 
 };
diff --git a/elements/userlevel/todevice.cc b/elements/userlevel/todevice.cc
index 31fa72b..cdd7da2 100644
--- a/elements/userlevel/todevice.cc
+++ b/elements/userlevel/todevice.cc
@@ -285,7 +285,7 @@ ToDevice::netmap_send_packet(Packet *p)
 {
     for (unsigned ri = _netmap.ring_begin; ri != _netmap.ring_end; ++ri) {
 	struct netmap_ring *ring = NETMAP_TXRING(_netmap.nifp, ri);
-	if (ring->avail == 0)
+	if (nm_ring_empty(ring))
 	    continue;
 	unsigned cur = ring->cur;
 	unsigned buf_idx = ring->slot[cur].buf_idx;
@@ -295,17 +295,17 @@ ToDevice::netmap_send_packet(Packet *p)
 	uint32_t p_length = p->length();
 	if (NetmapInfo::is_netmap_buffer(p)
 	    && !p->shared() && p->buffer() == p->data()
+	    && (char *)p->buffer() >= _netmap.mem && (char *)p->buffer() < _netmap.mem + _netmap.memsize
 	    && noutputs() == 0) {
 	    ring->slot[cur].buf_idx = NETMAP_BUF_IDX(ring, (char *) p->buffer());
 	    ring->slot[cur].flags |= NS_BUF_CHANGED;
-	    NetmapInfo::buffer_destructor(buf, 0);
+	    NetmapInfo::buffer_destructor(buf, 0, (void *)&_netmap);
 	    p->reset_buffer();
 	} else
 	    memcpy(buf, p->data(), p_length);
 	ring->slot[cur].len = p_length;
 	__asm__ volatile("" : : : "memory");
-	ring->cur = NETMAP_RING_NEXT(ring, cur);
-	ring->avail--;
+	ring->head = ring->cur = nm_ring_next(ring, cur);
 	return 0;
     }
     errno = ENOBUFS;
diff --git a/include/click/packet.hh b/include/click/packet.hh
index 165a6d3..d03a819 100644
--- a/include/click/packet.hh
+++ b/include/click/packet.hh
@@ -58,9 +58,10 @@ class Packet { public:
     static inline Packet *make(struct mbuf *mbuf) CLICK_WARN_UNUSED_RESULT;
 #endif
 #if CLICK_USERLEVEL
-    typedef void (*buffer_destructor_type)(unsigned char *buf, size_t sz);
+    typedef void (*buffer_destructor_type)(unsigned char *buf, size_t sz, void *arg);
     static WritablePacket *make(unsigned char *data, uint32_t length,
-				buffer_destructor_type buffer_destructor) CLICK_WARN_UNUSED_RESULT;
+				buffer_destructor_type buffer_destructor,
+				void *arg) CLICK_WARN_UNUSED_RESULT;
 #endif
 
     static void static_cleanup();
@@ -724,6 +725,7 @@ class Packet { public:
     unsigned char *_end;  /* one beyond end of allocated buffer */
 # if CLICK_USERLEVEL
     buffer_destructor_type _destructor;
+    void *_destructor_arg;
 # endif
 # if CLICK_BSDMODULE
     struct mbuf *_m;
diff --git a/lib/fromfile.cc b/lib/fromfile.cc
index 8827455..4b691d7 100644
--- a/lib/fromfile.cc
+++ b/lib/fromfile.cc
@@ -118,7 +118,7 @@ FromFile::warning(ErrorHandler *errh, const char *format, ...) const
 
 #ifdef ALLOW_MMAP
 static void
-munmap_destructor(unsigned char *data, size_t amount)
+munmap_destructor(unsigned char *data, size_t amount, void *arg)
 {
     if (munmap((caddr_t)data, amount) < 0)
 	click_chatter("FromFile: munmap: %s", strerror(errno));
@@ -156,7 +156,7 @@ FromFile::read_buffer_mmap(ErrorHandler *errh)
     if (mmap_data == MAP_FAILED)
 	return error(errh, "mmap: %s", strerror(errno));
 
-    _data_packet = Packet::make((unsigned char *)mmap_data, _len, munmap_destructor);
+    _data_packet = Packet::make((unsigned char *)mmap_data, _len, munmap_destructor, 0);
     _buffer = _data_packet->data();
     _file_offset = _mmap_off;
     _mmap_off += _len;
diff --git a/lib/packet.cc b/lib/packet.cc
index 65c35c0..3e048d7 100644
--- a/lib/packet.cc
+++ b/lib/packet.cc
@@ -212,7 +212,7 @@ Packet::~Packet()
 	_data_packet->kill();
 # if CLICK_USERLEVEL
     else if (_head && _destructor)
-	_destructor(_head, _end - _head);
+	_destructor(_head, _end - _head, _destructor_arg);
     else
 	delete[] _head;
 # elif CLICK_BSDMODULE
@@ -552,7 +552,7 @@ Packet::make(uint32_t headroom, const void *data,
  * null. */
 WritablePacket *
 Packet::make(unsigned char *data, uint32_t length,
-	     buffer_destructor_type destructor)
+	     buffer_destructor_type destructor, void *arg)
 {
 # if HAVE_CLICK_PACKET_POOL
     WritablePacket *p = WritablePacket::pool_allocate(false);
@@ -564,6 +564,7 @@ Packet::make(unsigned char *data, uint32_t length,
 	p->_head = p->_data = data;
 	p->_tail = p->_end = data + length;
 	p->_destructor = destructor;
+	p->_destructor_arg = arg;
     }
     return p;
 }
@@ -735,7 +736,7 @@ Packet::expensive_uniqueify(int32_t extra_headroom, int32_t extra_tailroom,
 	_data_packet->kill();
 # if CLICK_USERLEVEL
     else if (_destructor)
-	_destructor(old_head, old_end - old_head);
+	_destructor(old_head, old_end - old_head, _destructor_arg);
     else
 	delete[] old_head;
     _destructor = 0;
