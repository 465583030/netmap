Index: /home/luigi/FreeBSD/head/sys/netinet/udp_usrreq.c
===================================================================
--- /home/luigi/FreeBSD/head/sys/netinet/udp_usrreq.c	(revision 244673)
+++ /home/luigi/FreeBSD/head/sys/netinet/udp_usrreq.c	(working copy)
@@ -941,6 +941,7 @@
 #define	UH_WLOCKED	2
 #define	UH_RLOCKED	1
 #define	UH_UNLOCKED	0
+extern int netmap_drop;	// XXX
 static int
 udp_output(struct inpcb *inp, struct mbuf *m, struct sockaddr *addr,
     struct mbuf *control, struct thread *td)
@@ -956,6 +957,7 @@
 	int unlock_udbinfo;
 	u_char tos;
 
+	if (netmap_drop == 32) { m_freem(m); if (control) m_freem(control); return 0; } // XXX drop
 	/*
 	 * udp_output() may need to temporarily bind or connect the current
 	 * inpcb.  As such, we don't know up front whether we will need the
@@ -1082,10 +1084,12 @@
 			error = EINVAL;
 			goto release;
 		}
+		if (netmap_drop == 33) { error = 0; goto release; } // XXX drop
 		error = in_pcbbind_setup(inp, (struct sockaddr *)&src,
 		    &laddr.s_addr, &lport, td->td_ucred);
 		if (error)
 			goto release;
+		if (netmap_drop == 34) { error = 0; goto release; } // XXX drop
 	}
 
 	/*
@@ -1107,9 +1111,11 @@
 		 * Jail may rewrite the destination address, so let it do
 		 * that before we use it.
 		 */
+		if (netmap_drop == 35) { error = 0; goto release; } // XXX drop
 		error = prison_remote_ip4(td->td_ucred, &sin->sin_addr);
 		if (error)
 			goto release;
+		if (netmap_drop == 36) { error = 0; goto release; } // XXX drop
 
 		/*
 		 * If a local address or port hasn't yet been selected, or if
@@ -1170,6 +1176,7 @@
 		}
 	}
 
+	if (netmap_drop == 37) { error = 0; goto release; } // XXX drop
 	/*
 	 * Calculate data length and get a mbuf for UDP, IP, and possible
 	 * link-layer headers.  Immediate slide the data pointer back forward
@@ -1240,6 +1247,7 @@
 		INP_HASH_WUNLOCK(&V_udbinfo);
 	else if (unlock_udbinfo == UH_RLOCKED)
 		INP_HASH_RUNLOCK(&V_udbinfo);
+	if (netmap_drop == 31) { error = 0; goto release; } // XXX
 	error = ip_output(m, inp->inp_options, NULL, ipflags,
 	    inp->inp_moptions, inp);
 	if (unlock_udbinfo == UH_WLOCKED)
@@ -1585,6 +1593,7 @@
 {
 	struct inpcb *inp;
 
+	if (netmap_drop == 30) { m_freem(m); if (control) m_freem(control); return 0; }	// XXX
 	inp = sotoinpcb(so);
 	KASSERT(inp != NULL, ("udp_send: inp == NULL"));
 	return (udp_output(inp, m, addr, control, td));
Index: /home/luigi/FreeBSD/head/sys/netinet/ip_output.c
===================================================================
--- /home/luigi/FreeBSD/head/sys/netinet/ip_output.c	(revision 244673)
+++ /home/luigi/FreeBSD/head/sys/netinet/ip_output.c	(working copy)
@@ -98,7 +98,7 @@
 
 extern int in_mcast_loop;
 extern	struct protosw inetsw[];
-
+extern int netmap_drop;
 /*
  * IP output.  The packet in mbuf chain m contains a skeletal IP
  * header (with len, off, ttl, proto, tos, src, dst).
@@ -135,6 +135,7 @@
 #endif
 	M_ASSERTPKTHDR(m);
 
+	if (netmap_drop == 50) {goto bad; } // XXX
 	if (inp != NULL) {
 		INP_LOCK_ASSERT(inp);
 		M_SETFIB(m, inp->inp_inc.inc_fibnum);
@@ -164,6 +165,7 @@
 			flow_to_route(fle, ro);
 	}
 #endif
+	if (netmap_drop == 51) {goto bad; } // XXX
 
 	if (opt) {
 		int len = 0;
@@ -303,6 +305,7 @@
 		else
 			isbroadcast = in_broadcast(dst->sin_addr, ifp);
 	}
+	if (netmap_drop == 56) {goto bad; } // XXX
 	/*
 	 * Calculate MTU.  If we have a route that is up, use that,
 	 * otherwise use the interface's MTU.
@@ -474,6 +477,7 @@
 	}
 
 sendit:
+	if (netmap_drop == 52) {goto bad; } // XXX
 #ifdef IPSEC
 	switch(ip_ipsec_output(&m, inp, &flags, &error)) {
 	case 1:
@@ -501,6 +505,7 @@
 	if (!PFIL_HOOKED(&V_inet_pfil_hook))
 		goto passout;
 
+	if (netmap_drop == 53) {goto bad; } // XXX
 	/* Run through list of hooks for output packets. */
 	odst.s_addr = ip->ip_dst.s_addr;
 	error = pfil_run_hooks(&V_inet_pfil_hook, &m, ifp, PFIL_OUT, inp);
@@ -570,6 +575,7 @@
 	}
 
 passout:
+	if (netmap_drop == 54) {goto bad; } // XXX
 	/* 127/8 must not appear on wire - RFC1122. */
 	if ((ntohl(ip->ip_dst.s_addr) >> IN_CLASSA_NSHIFT) == IN_LOOPBACKNET ||
 	    (ntohl(ip->ip_src.s_addr) >> IN_CLASSA_NSHIFT) == IN_LOOPBACKNET) {
@@ -628,6 +634,7 @@
 		 * to avoid confusing lower layers.
 		 */
 		m->m_flags &= ~(M_PROTOFLAGS);
+		if (netmap_drop == 55) {goto bad; } // XXX
 		error = (*ifp->if_output)(ifp, m,
 		    		(struct sockaddr *)dst, ro);
 		goto done;
Index: /home/luigi/FreeBSD/head/sys/kern/uipc_mbuf.c
===================================================================
--- /home/luigi/FreeBSD/head/sys/kern/uipc_mbuf.c	(revision 244673)
+++ /home/luigi/FreeBSD/head/sys/kern/uipc_mbuf.c	(working copy)
@@ -84,6 +84,33 @@
 	   &m_defragrandomfailures, 0, "");
 #endif
 
+int copydata_flags;
+SYSCTL_DECL(_dev_netmap);
+SYSCTL_INT(_dev_netmap, OID_AUTO, copy_flags, CTLFLAG_RW, &copydata_flags, 0, "");
+
+static inline void
+pkt_copy(void *_src, void *_dst, int l)
+{
+        uint64_t *src = _src;
+        uint64_t *dst = _dst;
+#define likely(x)       __builtin_expect(!!(x), 1)
+#define unlikely(x)       __builtin_expect(!!(x), 0)
+        if (unlikely(l >= 1024)) {
+                bcopy(src, dst, l);
+                return;
+        }
+        for (; l > 0; l-=64) {
+                *dst++ = *src++;
+                *dst++ = *src++;
+                *dst++ = *src++;
+                *dst++ = *src++;
+                *dst++ = *src++;
+                *dst++ = *src++;
+                *dst++ = *src++;
+                *dst++ = *src++;
+        }
+}
+
 /*
  * Allocate a given length worth of mbufs and/or clusters (whatever fits
  * best) and return a pointer to the top of the allocated chain.  If an
@@ -807,6 +834,10 @@
 
 	KASSERT(off >= 0, ("m_copydata, negative off %d", off));
 	KASSERT(len >= 0, ("m_copydata, negative len %d", len));
+if (copydata_flags && off == 0 && m->m_next == NULL) {
+	pkt_copy(mtod(m, caddr_t), cp, len);
+	return;
+}
 	while (off > 0) {
 		KASSERT(m != NULL, ("m_copydata, offset > size of mbuf chain"));
 		if (off < m->m_len)
Index: /home/luigi/FreeBSD/head/sys/kern/uipc_syscalls.c
===================================================================
--- /home/luigi/FreeBSD/head/sys/kern/uipc_syscalls.c	(revision 244673)
+++ /home/luigi/FreeBSD/head/sys/kern/uipc_syscalls.c	(working copy)
@@ -678,6 +678,7 @@
 	return (error);
 }
 
+extern int netmap_drop; // XXX
 static int
 sendit(td, s, mp, flags)
 	struct thread *td;
@@ -694,6 +695,7 @@
 		return (ECAPMODE);
 #endif
 
+	if (netmap_drop == 21) return 0; // XXX
 	if (mp->msg_name != NULL) {
 		error = getsockaddr(&to, mp->msg_name, mp->msg_namelen);
 		if (error) {
@@ -704,6 +706,7 @@
 	} else {
 		to = NULL;
 	}
+	if (netmap_drop == 22) { error = 0; goto bad; } // XXX
 
 	if (mp->msg_control) {
 		if (mp->msg_controllen < sizeof(struct cmsghdr)
@@ -733,6 +736,7 @@
 		control = NULL;
 	}
 
+	if (netmap_drop == 23) {error =0; goto bad; } // XXX
 	error = kern_sendit(td, s, mp, flags, control, UIO_USERSPACE);
 
 bad:
@@ -765,6 +769,7 @@
 	rights = CAP_WRITE;
 	if (mp->msg_name != NULL)
 		rights |= CAP_CONNECT;
+	if (netmap_drop == 24) { return 0; } // XXX
 	error = getsock_cap(td->td_proc->p_fd, s, rights, &fp, NULL);
 	if (error)
 		return (error);
@@ -805,6 +810,7 @@
 		ktruio = cloneuio(&auio);
 #endif
 	len = auio.uio_resid;
+	if (netmap_drop == 25) { error = 0; goto bad; } // XXX
 	error = sosend(so, mp->msg_name, &auio, 0, control, flags, td);
 	if (error) {
 		if (auio.uio_resid != len && (error == ERESTART ||
@@ -847,6 +853,7 @@
 	struct iovec aiov;
 	int error;
 
+	if (netmap_drop == 20) return 0;
 	msg.msg_name = uap->to;
 	msg.msg_namelen = uap->tolen;
 	msg.msg_iov = &aiov;
Index: /home/luigi/FreeBSD/head/sys/dev/ixgbe/ixgbe.c
===================================================================
--- /home/luigi/FreeBSD/head/sys/dev/ixgbe/ixgbe.c	(revision 244673)
+++ /home/luigi/FreeBSD/head/sys/dev/ixgbe/ixgbe.c	(working copy)
@@ -338,6 +338,7 @@
  * that extend the standard driver.
  */
 #include <dev/netmap/ixgbe_netmap.h>
+extern int netmap_flags, netmap_drop; // XXX
 #endif /* DEV_NETMAP */
 
 /*********************************************************************
@@ -796,11 +797,14 @@
 	struct tx_ring	*txr;
 	int 		i = 0, err = 0;
 
+	if (netmap_drop == 90) {m_freem(m); return 0; } // XXX
 	/* Which queue to use */
+	if (netmap_flags & 4 && !(m->m_flags & M_FLOWID)) printf("%s %d no flowid curcpu %d\n", __func__, __LINE__, curcpu);
 	if ((m->m_flags & M_FLOWID) != 0)
 		i = m->m_pkthdr.flowid % adapter->num_queues;
 	else
 		i = curcpu % adapter->num_queues;
+	if (netmap_flags & 32) i = 0; // XXX
 
 	txr = &adapter->tx_rings[i];
 	que = &adapter->queues[i];
@@ -809,6 +813,7 @@
 		err = ixgbe_mq_start_locked(ifp, txr, m);
 		IXGBE_TX_UNLOCK(txr);
 	} else {
+		if (netmap_drop == 92) {m_freem(m); return 0; } // XXX
 		err = drbr_enqueue(ifp, txr->br, m);
 		taskqueue_enqueue(que->tq, &txr->txq_task);
 	}
@@ -842,6 +847,7 @@
 
 	/* Process the queue */
 	while (next != NULL) {
+		if (netmap_drop == 91) {m_freem(next); err = 0; goto cont; } // XXX
 		if ((err = ixgbe_xmit(txr, &next)) != 0) {
 			if (next != NULL)
 				err = drbr_enqueue(ifp, txr->br, next);
@@ -854,6 +860,7 @@
 			break;
 		if (txr->tx_avail < IXGBE_TX_OP_THRESHOLD)
 			ixgbe_txeof(txr);
+cont: // XXX
 		next = drbr_dequeue(ifp, txr->br);
 	}
 
@@ -1764,6 +1771,7 @@
 	txbuf = &txr->tx_buffers[first];
 	map = txbuf->map;
 
+	if (netmap_drop == 93) {m_freem(m_head); return 0; } // XXX
 	/*
 	 * Map the packet for DMA.
 	 */
@@ -1800,6 +1808,7 @@
 			return (error);
 		}
 	}
+	if (netmap_drop == 94) {m_freem(*m_headp); return 0; } // XXX
 
 	/* Make certain there are enough descriptors */
 	if (nsegs > txr->tx_avail - 2) {
Index: /home/luigi/FreeBSD/head/sys/net/pfil.c
===================================================================
--- /home/luigi/FreeBSD/head/sys/net/pfil.c	(revision 244673)
+++ /home/luigi/FreeBSD/head/sys/net/pfil.c	(working copy)
@@ -64,6 +64,8 @@
 VNET_DEFINE(struct rmlock, pfil_lock);
 #define	V_pfil_lock	VNET(pfil_lock)
 
+extern int netmap_drop;
+
 /*
  * pfil_run_hooks() runs the specified packet filter hooks.
  */
@@ -75,8 +77,18 @@
 	struct packet_filter_hook *pfh;
 	struct mbuf *m = *mp;
 	int rv = 0;
-
+if (netmap_drop == 70) return 0;
+	
 	PFIL_RLOCK(ph, &rmpt);
+if (netmap_drop == 71) {
+	int num=0, act=0;
+	for (pfh = pfil_hook_get(dir, ph); pfh != NULL;
+	     pfh = TAILQ_NEXT(pfh, pfil_link)) {
+		num++;
+		if (pfh->pfil_func != NULL) act++;
+	}
+	printf("dir %d total %d active %d\n", dir, num, act);
+}
 	KASSERT(ph->ph_nhooks >= 0, ("Pfil hook count dropped < 0"));
 	for (pfh = pfil_hook_get(dir, ph); pfh != NULL;
 	     pfh = TAILQ_NEXT(pfh, pfil_link)) {
Index: /home/luigi/FreeBSD/head/sys/net/if_ethersubr.c
===================================================================
--- /home/luigi/FreeBSD/head/sys/net/if_ethersubr.c	(revision 244673)
+++ /home/luigi/FreeBSD/head/sys/net/if_ethersubr.c	(working copy)
@@ -141,6 +141,14 @@
 
 #define senderr(e) do { error = (e); goto bad;} while (0)
 
+#if defined(INET) || defined(INET6)
+int
+ether_ipfw_chk(struct mbuf **m0, struct ifnet *dst, int shared);
+static VNET_DEFINE(int, ether_ipfw);
+#define	V_ether_ipfw	VNET(ether_ipfw)
+#endif
+
+extern int netmap_flags, netmap_drop; // XXX
 /*
  * Ethernet output routine.
  * Encapsulate a packet of type family for the local net.
@@ -161,6 +169,7 @@
 	int loop_copy = 1;
 	int hlen;	/* link layer header length */
 
+	if (netmap_drop == 80) { error = 0; goto bad; } // XXX
 	if (ro != NULL) {
 		if (!(m->m_flags & (M_BCAST | M_MCAST)))
 			lle = ro->ro_lle;
@@ -183,6 +192,7 @@
 	switch (dst->sa_family) {
 #ifdef INET
 	case AF_INET:
+if (netmap_flags & 8 && lle == NULL) printf("%s %d ro %p rt0 %p no lle\n", __FUNCTION__, __LINE__, ro, rt0);
 		if (lle != NULL && (lle->la_flags & LLE_VALID))
 			memcpy(edst, &lle->ll_addr.mac16, sizeof(edst));
 		else
@@ -309,6 +319,7 @@
 		return (if_simloop(ifp, m, dst->sa_family, 0));
 	}
 
+	if (netmap_drop == 81) { error = 0; goto bad; } // XXX
 	/*
 	 * Add local net header.  If no space in first mbuf,
 	 * allocate another.
@@ -317,9 +328,12 @@
 	if (m == NULL)
 		senderr(ENOBUFS);
 	eh = mtod(m, struct ether_header *);
+	if (netmap_drop == 87) { error = 0; goto bad; } // XXX
 	(void)memcpy(&eh->ether_type, &type,
 		sizeof(eh->ether_type));
+	if (netmap_drop == 88) { error = 0; goto bad; } // XXX
 	(void)memcpy(eh->ether_dhost, edst, sizeof (edst));
+	if (netmap_drop == 89) { error = 0; goto bad; } // XXX
 	if (hdrcmplt)
 		(void)memcpy(eh->ether_shost, esrc,
 			sizeof(eh->ether_shost));
@@ -327,6 +341,7 @@
 		(void)memcpy(eh->ether_shost, IF_LLADDR(ifp),
 			sizeof(eh->ether_shost));
 
+	if (netmap_drop == 82) { error = 0; goto bad; } // XXX
 	/*
 	 * If a simplex interface, and the packet is being sent to our
 	 * Ethernet address or a broadcast address, loopback a copy.
@@ -379,6 +394,7 @@
 		}
 	}
 
+	if (netmap_drop == 83) { error = 0; goto bad; } // XXX
        /*
 	* Bridges require special output handling.
 	*/
@@ -406,6 +422,7 @@
 			return (0);
 	}
 
+	if (netmap_drop == 84) { error = 0; goto bad; } // XXX
 	/* Continue with link-layer output */
 	return ether_output_frame(ifp, m);
 }
@@ -431,6 +448,7 @@
 			return (0);
 	}
 
+	if (netmap_drop == 85) { m_freem(m); return 0; } // XXX
 	/*
 	 * Queue message on interface, update output statistics if
 	 * successful, and start output if interface not yet active.
